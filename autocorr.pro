FUNCTION autocorr, $
   series, $
   lags, $
   ignore_below, $
   ignore_above, $
   nval, $
   armean, $
   var, $
   ncv, $
   cov, $
   cor, $
   VERBOSE = verbose, $
   DEBUG = debug, $
   EXCPT_COND = excpt_cond

   ;Sec-Doc
   ;  PURPOSE: This function computes the autocovariance and
   ;  autocorrelation statistics on a series that may contain an arbitrary
   ;  number of missing values arbitrarily distributed within the series.
   ;
   ;  ALGORITHM: This function computes the arithmetic mean, variance,
   ;  autocovariance and autocorrelation statistics for all values of a
   ;  series that lie between ignore_below and ignore_above. In the
   ;  statistical literature, the normalization of the autocorrelation is
   ;  typically done by dividing the sum of the products by the number of
   ;  elements in the original series (thus ignoring the presence of
   ;  missing values) or by that number minus the lag, to account for the
   ;  smaller number of pairs of points contributing to the covariance at
   ;  larger lags. Here, the normalization is made by the number of valid
   ;  values in the series. This matches the convention used in IDL’s own
   ;  function A_CORRELATE and the recommendations of Datta and Du (2012)
   ;  [See the References section below].
   ;
   ;  SYNTAX: rc = autocorr(series, lags, ignore_below, ignore_above, $
   ;  nval, armean, var, ncv, cov, cor, $
   ;  VERBOSE = verbose, DEBUG = debug, EXCPT_COND = excpt_cond)
   ;
   ;  POSITIONAL PARAMETERS [INPUT/OUTPUT]:
   ;
   ;  *   series {FLOAT array} [I]: The series of values to be analyzed.
   ;
   ;  *   lags {INT array} [I]: The lags to consider.
   ;
   ;  *   ignore_below {FLOAT} [I]: The threshold below which values in
   ;      series should be ignored.
   ;
   ;  *   ignore_above {FLOAT} [I]: The threshold above which values in
   ;      series should be ignored.
   ;
   ;  *   nval {LONG} [O]: The number of valid values in series.
   ;
   ;  *   armean {FLOAT} [O]: The arithmetic mean of the valid values in
   ;      series.
   ;
   ;  *   var {FLOAT} [O]: The variance of the valid values in series.
   ;
   ;  *   ncv {INT array} [O]: The number of pairs of valid values in
   ;      series contributing to the autocovariance and autocorrelation
   ;      functions at each of the lags: this value is not used in the
   ;      computation but may serves as an empirical diagnostic of the
   ;      reliability of those functions.
   ;
   ;  *   cov {FLOAT array} [O]: The autocovariances of the series at the
   ;      specified lags.
   ;
   ;  *   cor {FLOAT array} [O]: The autocorrelations of the series at the
   ;      specified lags.
   ;
   ;  KEYWORD PARAMETERS [INPUT/OUTPUT]:
   ;
   ;  *   VERBOSE = verbose {INT} [I] (Default value: 0): Flag to enable
   ;      (> 0) or skip (0) outputting messages on the console:
   ;
   ;      -   If verbose > 0, messages inform the user about progress in
   ;          the execution of time-consuming routines, or the location of
   ;          output files (e.g., log, map, plot, etc.);
   ;
   ;      -   If verbose > 1, messages record entering and exiting the
   ;          routine; and
   ;
   ;      -   If verbose > 2, messages provide additional information
   ;          about intermediary results.
   ;
   ;  *   DEBUG = debug {INT} [I] (Default value: 0): Flag to activate (1)
   ;      or skip (0) debugging tests.
   ;
   ;  *   EXCPT_COND = excpt_cond {STRING} [O] (Default value: ”):
   ;      Description of the exception condition if one has been
   ;      encountered, or a null string otherwise.
   ;
   ;  RETURNED VALUE TYPE: INT.
   ;
   ;  OUTCOME:
   ;
   ;  *   If no exception condition has been detected, this function
   ;      returns 0, and the output keyword parameter excpt_cond is set to
   ;      a null string, if the optional input keyword parameter DEBUG is
   ;      set and if the optional output keyword parameter EXCPT_COND is
   ;      provided in the call. The output positional parameters contain
   ;      the results generated by this function.
   ;
   ;  *   If an exception condition has been detected, this function
   ;      returns a non-zero error code, and the output keyword parameter
   ;      excpt_cond contains a message about the exception condition
   ;      encountered, if the optional input keyword parameter DEBUG is
   ;      set and if the optional output keyword parameter EXCPT_COND is
   ;      provided. The output positional parameters may be incomplete or
   ;      incorrect.
   ;
   ;  EXCEPTION CONDITIONS:
   ;
   ;  *   Warning 98: The computer has not been recognized by the function
   ;      get_host_info.pro.
   ;
   ;  *   Error 100: One or more positional parameter(s) are missing.
   ;
   ;  *   Error 110: The input positional parameter misr_mode is invalid.
   ;
   ;  *   Error 120: The input positional parameter misr_path is invalid.
   ;
   ;  *   Error 130: The input positional parameter misr_orbit is invalid.
   ;
   ;  *   Error 132: The input positional parameter misr_orbit is
   ;      inconsistent with the input positional parameter misr_path.
   ;
   ;  *   Error 134: An exception condition occurred in is_frompath.pro.
   ;
   ;  *   Error 136: Unexpected return code received from is_frompath.pro.
   ;
   ;  *   Error 140: The input positional parameter misr_block is invalid.
   ;
   ;  *   Error 199: An exception condition occurred in
   ;      set_roots_vers.pro.
   ;
   ;  *   Error 200: An exception condition occurred in function
   ;      path2str.pro.
   ;
   ;  *   Error 210: An exception condition occurred in function
   ;      orbit2str.pro.
   ;
   ;  *   Error 220: An exception condition occurred in function
   ;      block2str.pro.
   ;
   ;  *   Error 230: An exception condition occurred in function
   ;      orbit2date.pro.
   ;
   ;  *   Error 299: The computer is not recognized and at least one of
   ;      the optional input keyword parameters l1b2_folder, ...,
   ;      map_folder is not specified.
   ;
   ;  *   Error 300: The input folder l1b2_path is unreadable.
   ;
   ;  *   Error 400: The output folder log_path is unwritable.
   ;
   ;  *   Error 500: An exception condition occurred in function
   ;      fname.pro.
   ;
   ;  *   Error 600: An exception condition occurred in the MISR TOOLKIT
   ;      routine
   ;      MTK_SETREGION_BY_PATH_BLOCKRANGE.
   ;
   ;  DEPENDENCIES:
   ;
   ;  *   MISR Toolkit
   ;
   ;  *   is_numeric.pro
   ;
   ;  *   strstr.pro
   ;
   ;  REMARKS:
   ;
   ;  *   NOTE 1: The computations are carried out in DOUBLE precision.
   ;
   ;  *   NOTE 2: The autocovariance at lag l is set to -999.0 if there
   ;      are fewer than 2 valid values.
   ;
   ;  *   NOTE 3: The autocorrelation at lag l is set to -999.0 if the
   ;      autocovariance at that lag is negative or if the variance of the
   ;      entire series of valid values is null.
   ;
   ;  EXAMPLES:
   ;
   ;      IDL> series = [3.73, 3.67, 3.77, 3.83, 4.67, $
   ;         5.87, 6.70, 6.97, 6.40, 5.57]
   ;      IDL> lags = [-3, 0, 1, 3, 4, 8]
   ;      IDL> ignore_below = -10.0
   ;      IDL> ignore_above = 10.0
   ;      IDL> rc = autocorr(series, lags, ignore_below, $
   ;         ignore_above, nval, armean, var, ncv, cov, cor, $
   ;         VERBOSE = verbose, DEBUG = debug, EXCPT_COND = excpt_cond)
   ;      IDL> PRINT, 'cov = ', cov
   ;      cov =  0.023456856  1.6045959  1.3011335  0.023456856
   ;         -0.52194154  -0.24339123
   ;      IDL> PRINT, 'cor = ', cor
   ;      cor =  0.014618544  1.0000000  0.81087926  0.014618544
   ;         -0.32527912  -0.15168382
   ;
   ;  REFERENCES:
   ;
   ;  *   Box, G. and G. Jenkins (1976) ’Time Series Analysis’,
   ;      Holden-Day.
   ;
   ;  *   Fuller, W. (1976) ’Introduction to Statistical Time Series’,
   ;      Wiley.
   ;
   ;  *   Datta, D. D. and Du, W. (2012) ’Nonparametric HAC Estimation for
   ;      Time Sereis Data with Missing Observations’, Board of Governots
   ;      of the Federal Reserve System, International Finance Discussion
   ;      Papers number 1060, available from
   ;      https://www.federalreserve.gov/pubs/ifdp/2012/1060/ifdp1060.htm,
   ;      accessed on 11 October 2019.
   ;
   ;  *   URL: http://en.wikipedia.org/wiki/Autocorrelation, first
   ;      accessed on 18 February 2007, and again on 11 October 2019.
   ;
   ;  VERSIONING:
   ;
   ;  *   2007–02–18: Version 1.0 — Initial public release.
   ;
   ;  *   2019–10–12: Version 2.1.0 — Adopt revised coding and
   ;      documentation standards, and switch to 3-parts version
   ;      identifiers.
   ;Sec-Lic
   ;  INTELLECTUAL PROPERTY RIGHTS
   ;
   ;  *   Copyright (C) 2017-2019 Michel M. Verstraete.
   ;
   ;      Permission is hereby granted, free of charge, to any person
   ;      obtaining a copy of this software and associated documentation
   ;      files (the “Software”), to deal in the Software without
   ;      restriction, including without limitation the rights to use,
   ;      copy, modify, merge, publish, distribute, sublicense, and/or
   ;      sell copies of the Software, and to permit persons to whom the
   ;      Software is furnished to do so, subject to the following three
   ;      conditions:
   ;
   ;      1. The above copyright notice and this permission notice shall
   ;      be included in its entirety in all copies or substantial
   ;      portions of the Software.
   ;
   ;      2. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY
   ;      KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
   ;      WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
   ;      AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
   ;      HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
   ;      WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   ;      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   ;      OTHER DEALINGS IN THE SOFTWARE.
   ;
   ;      See: https://opensource.org/licenses/MIT.
   ;
   ;      3. The current version of this Software is freely available from
   ;
   ;      https://github.com/mmverstraete.
   ;
   ;  *   Feedback
   ;
   ;      Please send comments and suggestions to the author at
   ;      MMVerstraete@gmail.com
   ;Sec-Cod

   COMPILE_OPT idl2, HIDDEN

   ;  Get the name of this routine:
   info = SCOPE_TRACEBACK(/STRUCTURE)
   rout_name = info[N_ELEMENTS(info) - 1].ROUTINE

   ;  Initialize the default return code:
   return_code = 0

   ;  Set the default values of flags and essential keyword parameters:
   IF (KEYWORD_SET(verbose)) THEN BEGIN
      IF (is_numeric(verbose)) THEN verbose = FIX(verbose) ELSE verbose = 0
      IF (verbose LT 0) THEN verbose = 0
      IF (verbose GT 3) THEN verbose = 3
   ENDIF ELSE verbose = 0
   IF (KEYWORD_SET(debug)) THEN debug = 1 ELSE debug = 0
   excpt_cond = ''

   IF (verbose GT 1) THEN PRINT, 'Entering ' + rout_name + '.'

   IF (debug) THEN BEGIN

   ;  Return to the calling routine with an error message if one or more
   ;  positional parameters are missing:
      n_reqs = 10
      IF (N_PARAMS() NE n_reqs) THEN BEGIN
         error_code = 100
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': Routine must be called with ' + strstr(n_reqs) + $
            ' positional parameter(s): series, lags, ignore_below, ' + $
            'ignore_above, nval, armean, var, ncv, cov, cor.'
         RETURN, error_code
      ENDIF

   ;  Return to the calling routine with an error message if the input
   ;  positional parameter 'series' is not a numeric array:
      IF ((is_numeric(series) NE 1) OR $
         (is_array(series) NE 1)) THEN BEGIN
         error_code = 110
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': The input positional parameter series is not a numeric array.'
         RETURN, error_code
      ENDIF

   ;  Return to the calling routine with an error message if the input
   ;  positional parameter 'series' does not include at least 3 elements:
      IF (N_ELEMENTS(series) LT 2) THEN BEGIN
         error_code = 120
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': The input positional parameter series does not have at ' + $
            'least 2 elements.'
         RETURN, error_code
      ENDIF

   ;  Return to the calling routine with an error message if the input
   ;  positional parameter 'lags' is not a numeric array:
      IF ((is_numeric(lags) NE 1) OR $
         (is_array(lags) NE 1)) THEN BEGIN
         error_code = 130
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': The input positional parameter lags is not a numeric array.'
         RETURN, error_code
      ENDIF

   ;  Return to the calling routine with an error message if the input
   ;  positional parameter 'lags' does not include at least 1 element:
      IF (N_ELEMENTS(lags) LT 1) THEN BEGIN
         error_code = 140
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': The input positional parameter lags does not have at ' + $
            'least 1 element.'
         RETURN, error_code
      ENDIF

   ;  Return to the calling routine with an error message if the input
   ;  positional parameter 'ignore_below' is not a scalar number:
      IF ((is_numeric(ignore_below) NE 1) OR $
         (is_scalar(ignore_below) NE 1)) THEN BEGIN
         error_code = 150
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': The input positional parameter ignore_below is not a ' + $
            'numeric scalar.'
         RETURN, error_code
      ENDIF

   ;  Return to the calling routine with an error message if the input
   ;  positional parameter 'ignore_above' is not a scalar number:
      IF ((is_numeric(ignore_above) NE 1) OR $
         (is_scalar(ignore_above) NE 1)) THEN BEGIN
         error_code = 160
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': The input positional parameter ignore_above is not a ' + $
            'numeric scalar.'
         RETURN, error_code
      ENDIF

   ;  Return to the calling routine with an error message if the input
   ;  positional parameters 'ignore_below' and 'ignore_above' are incompatible:
      IF (ignore_below GE ignore_above) THEN BEGIN
         error_code = 170
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': The input positional parameters ignore_below and ' + $
            'ignore_above are incompatible.'
         RETURN, error_code
      ENDIF
   ENDIF

   ;  Evaluate the number of elements in the series:
   nelm = N_ELEMENTS(series)

   ;  Evaluate the number of lags required:
   nlags = N_ELEMENTS(lags)

   ;  Without loss of generality, ensure that all lags are positive:
   lags = ABS(lags)

   ;  Define the output arguments:
   nval = 0L
   sum = 0.0D
   armean = 0.0D
   var = 0.0D
   ncv = INTARR(nlags)
   cov = DBLARR(nlags)
   cor = DBLARR(nlags)

   ;  Sift the valid values within the array 'series':
   idx = WHERE((series GE ignore_below) AND (series LE ignore_above), nval)
   IF (nval LT 2) THEN BEGIN
      error_code = 200
      excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
         ': The input positional parameter series does not contain at ' + $
         'least 2 valid values.'
      RETURN, error_code
   ENDIF

   ;  Compute the arithmetic mean of the valid values:
   sum = TOTAL(series[idx], /DOUBLE)
   armean = sum / nval

   ;  Estimate the (unbiased) variance of all valid values in the series:
   var = TOTAL((series[idx] - armean) * (series[idx] - armean), /DOUBLE)
   var = var / nval

   ;  Estimate the sum of the lagged products and the autocorrelation:

   ;  For each of the requested lags:
   FOR l = 0, nlags - 1 DO BEGIN

   ;  Initialize the counter of the number of contributing values and
   ;  the covariance at this lag:
      ncv[l] = 0
      cov[l] = 0.0D

   ;  For each couple of values at that lag:
      FOR i = 0, (nelm - lags[l] - 1) DO BEGIN

   ;  Check that both values are valid; if so compute their product and
   ;  increment the applicable counter:
         IF (((series[i] GE ignore_below) AND $
            (series[i] LE ignore_above)) AND $
            ((series[i + lags[l]] GE ignore_below) AND $
            (series[i + lags[l]] LE ignore_above))) THEN BEGIN
               cov[l] = cov[l] + $
                  (series[i] - armean) * (series[i + lags[l]] - armean)
               ncv[l] = ncv[l] + 1
         ENDIF
      ENDFOR

   ;  Compute the autocovariance at the current lag:
      IF (nval LT 2) THEN BEGIN
         cov[l] = -999.0D
         cor[l] = -999.0D
      ENDIF ELSE BEGIN
         cov[l] = cov[l] / nval
      ENDELSE

   ;  Compute the autocorrelation only if the autocovariance at lag l is
   ;  positive and if the variance of the valid values is strictly positive:
      IF (var GT 0.0) THEN BEGIN
         cor[l] = cov[l] / var
      ENDIF ELSE BEGIN
         cor[l] = -999.0D
      ENDELSE
   ENDFOR

   IF (verbose GT 1) THEN PRINT, 'Exiting ' + rout_name + '.'

   RETURN, return_code

END
