FUNCTION n_min_max, $
   series, $
   n_seqs, $
   n_mins, $
   mins, $
   i_mins, $
   n_maxs, $
   maxs, $
   i_maxs, $
   MISSING = missing, $
   IGNORE_BELOW = ignore_below, $
   IGNORE_ABOVE = ignore_above, $
   DEBUG = debug, $
   EXCPT_COND = excpt_cond

   ;Sec-Doc
   ;  PURPOSE: This function computes the number of local minima and
   ;  maxima in the input numerical array series, optionally ignoring
   ;  values that are strictly smaller than ignore_below or that are
   ;  strictly larger than ignore_above, and provides their values and
   ;  positions in the series.
   ;
   ;  ALGORITHM: This function identifies the number of times sequences of
   ;  continuously increasing values are followed by sequences of
   ;  continuously decreasing values, and conversely, in the input
   ;  numerical array series. Once these numbers are known, appropriately
   ;  sized arrays are generated and populated with the desired
   ;  information.
   ;
   ;  SYNTAX: rc = n_min_max(series, n_seqs, n_mins, mins, i_mins, $
   ;  n_maxs, maxs, i_maxs, MISSING = missing, $
   ;  IGNORE_BELOW = ignore_below, IGNORE_ABOVE = ignore_above, $
   ;  DEBUG = debug, EXCPT_COND = excpt_cond)
   ;
   ;  POSITIONAL PARAMETERS [INPUT/OUTPUT]:
   ;
   ;  *   series {FLOAT array} [I]: A 1-dimensional input numerical array
   ;      of arbitrary size.
   ;
   ;  *   n_seqs {LONG} [O]: The number of uninterrupted sequences (runs)
   ;      of consecutive valid (i.e., containing no missing) values in the
   ;      input numerical array series.
   ;
   ;  *   n_mins {LONG} [O]: The number of local minima found in the input
   ;      numerical array series.
   ;
   ;  *   mins {FLOAT array} [O]: The values of the local minima found in
   ;      the input numerical array series.
   ;
   ;  *   i_mins {LONG} [O]: The positions of these local minima within
   ;      the input numerical array series.
   ;
   ;  *   n_maxs {LONG} [O]: The number of local maxima found in the input
   ;      numerical array series.
   ;
   ;  *   maxs {FLOAT array} [O]: The values of the local maxima found in
   ;      the input numerical array series.
   ;
   ;  *   i_maxs {LONG} [O]: The positions of these local maxima within
   ;      the input numerical array series.
   ;
   ;  KEYWORD PARAMETERS [INPUT/OUTPUT]:
   ;
   ;  *   MISSING = missing {INT} [I] (Default value: 0): Flag to indicate
   ;      whether the input numerical array series contains missing values
   ;      (1) or not (0). If it does, then the input keyword parameters
   ;      IGNORE_BELOW and IGNORE_ABOVE are both required.
   ;
   ;  *   IGNORE_BELOW = ignore_below {FLOAT } [I]: The numerical
   ;      threshold below which all values of the input numerical array
   ;      series must be ignored.
   ;
   ;  *   IGNORE_ABOVE = ignore_above {FLOAT } [I]: The numerical
   ;      threshold above which all values of the input numerical array
   ;      series must be ignored.
   ;
   ;  *   DEBUG = debug {INT} [I] (Default value: 0): Flag to activate (1)
   ;      or skip (0) debugging tests.
   ;
   ;  *   EXCPT_COND = excpt_cond {STRING} [O] (Default value: ”):
   ;      Description of the exception condition if one has been
   ;      encountered, or a null string otherwise.
   ;
   ;  RETURNED VALUE TYPE: INT.
   ;
   ;  OUTCOME:
   ;
   ;  *   If no exception condition has been detected, this function
   ;      returns 0, and the output keyword parameter excpt_cond is set to
   ;      a null string, if the optional input keyword parameter DEBUG is
   ;      set and if the optional output keyword parameter EXCPT_COND is
   ;      provided in the call. The output positional parameters contain
   ;      the results generated by this function.
   ;
   ;  *   If an exception condition has been detected, this function
   ;      returns a non-zero error code, and the output keyword parameter
   ;      excpt_cond contains a message about the exception condition
   ;      encountered, if the optional input keyword parameter DEBUG is
   ;      set and if the optional output keyword parameter EXCPT_COND is
   ;      provided. The output positional parameters may be incomplete or
   ;      incorrect.
   ;
   ;  EXCEPTION CONDITIONS:
   ;
   ;  *   Error 100: One or more positional parameter(s) are missing.
   ;
   ;  *   Error 110: The input positional parameters series is not a
   ;      numerical array.
   ;
   ;  *   Error 120: The input keyword parameter missing is set and the
   ;      input keyword parameters ignore_below and ignore_above are
   ;      identical.
   ;
   ;  *   Error 130: The input positional parameter series does not
   ;      contain at least 3 valid values.
   ;
   ;  *   Error 200: The input positional parameter series does not
   ;      contain at least 1 sequence of at least 1 valid value.
   ;
   ;  *   Error 210: No minimum or no maximum was found in the input
   ;      positional parameter series.
   ;
   ;  DEPENDENCIES:
   ;
   ;  *   is_array.pro
   ;
   ;  *   is_numeric.pro
   ;
   ;  *   strstr.pro
   ;
   ;  REMARKS:
   ;
   ;  *   NOTE 1: No local minimum or maximum is assigned to an
   ;      uninterrupted sequence (or run) where all (valid) values are
   ;      equal, though the sequence itself is properly identified.
   ;
   ;  EXAMPLES:
   ;
   ;      IDL> series = [1.1, 2.1, 1.2, 2.4, 5.6, 4.3]
   ;      IDL> rc = n_min_max(series, n_seqs, $
   ;         n_mins, mins, i_mins, n_maxs, maxs, i_maxs)
   ;      IDL> PRINT, 'n_seqs = ', n_seqs
   ;      n_seqs =            1
   ;      IDL> PRINT, 'n_mins = ', n_mins
   ;      n_mins =            3
   ;      IDL> PRINT, 'mins = ', mins
   ;      mins =       1.10000      1.20000      4.30000
   ;      IDL> PRINT, 'i_mins = ', i_mins
   ;      i_mins =            0           2           5
   ;      IDL> PRINT, 'n_maxs = ', n_maxs
   ;      n_maxs =            2
   ;      IDL> PRINT, 'maxs = ', maxs
   ;      maxs =       2.10000      5.60000
   ;      IDL> PRINT, 'i_maxs = ', i_maxs
   ;      i_maxs =            1           4
   ;
   ;  REFERENCES: None.
   ;
   ;  VERSIONING:
   ;
   ;  *   2007–07–14: Version 0.9 — Initial release.
   ;
   ;  *   2019–12–01: Version 1.0 — Initial public release.
   ;
   ;  *   2019–12–06: Version 2.1.0 — Adopt revised coding and
   ;      documentation standards, and switch to 3-parts version
   ;      identifiers.
   ;Sec-Lic
   ;  INTELLECTUAL PROPERTY RIGHTS
   ;
   ;  *   Copyright (C) 2017-2019 Michel M. Verstraete.
   ;
   ;      Permission is hereby granted, free of charge, to any person
   ;      obtaining a copy of this software and associated documentation
   ;      files (the “Software”), to deal in the Software without
   ;      restriction, including without limitation the rights to use,
   ;      copy, modify, merge, publish, distribute, sublicense, and/or
   ;      sell copies of the Software, and to permit persons to whom the
   ;      Software is furnished to do so, subject to the following three
   ;      conditions:
   ;
   ;      1. The above copyright notice and this permission notice shall
   ;      be included in its entirety in all copies or substantial
   ;      portions of the Software.
   ;
   ;      2. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY
   ;      KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
   ;      WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
   ;      AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
   ;      HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
   ;      WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   ;      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   ;      OTHER DEALINGS IN THE SOFTWARE.
   ;
   ;      See: https://opensource.org/licenses/MIT.
   ;
   ;      3. The current version of this Software is freely available from
   ;
   ;      https://github.com/mmverstraete.
   ;
   ;  *   Feedback
   ;
   ;      Please send comments and suggestions to the author at
   ;      MMVerstraete@gmail.com
   ;Sec-Cod

   COMPILE_OPT idl2, HIDDEN

   ;  Get the name of this routine:
   info = SCOPE_TRACEBACK(/STRUCTURE)
   rout_name = info[N_ELEMENTS(info) - 1].ROUTINE

   ;  Initialize the default return code:
   return_code = 0

   ;  Set the default values of flags and essential keyword parameters:
   IF (KEYWORD_SET(missing)) THEN BEGIN
      missing = 1
      IF (~KEYWORD_SET(ignore_below)) THEN ignore_below = 0.0
      IF (~KEYWORD_SET(ignore_above)) THEN ignore_above = 0.0
   ENDIF ELSE BEGIN
      missing = 0
      res = MACHAR()
      ignore_below = -res.XMAX
      ignore_above = res.XMAX
   ENDELSE
   IF (KEYWORD_SET(debug)) THEN debug = 1 ELSE debug = 0
   excpt_cond = ''

   ;  Initialize the output positional parameters:
   n_seqs = 0L
   n_mins = 0L
   n_maxs = 0L

   IF (debug) THEN BEGIN

   ;  Return to the calling routine with an error message if one or more
   ;  positional parameters are missing:
      n_reqs = 8
      IF (N_PARAMS() NE n_reqs) THEN BEGIN
         error_code = 100
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': Routine must be called with ' + strstr(n_reqs) + $
            ' positional parameters: series, n_seqs, n_mins, mins, ' + $
            'n_maxs, maxs, i_mins, i_maxs.'
         RETURN, error_code
      ENDIF

   ;  Return to the calling routine with an error message if the input
   ;  positional parameter 'series' is not numeric or not an array:
      res1 = is_numeric(series)
      res2 = is_array(series)
      IF ((res1 NE 1) OR (res2 NE 1)) THEN BEGIN
         error_code = 110
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': The input positional parameters series is not a numerical array.'
         RETURN, error_code
      ENDIF

   ;  Check that the input keyword parameters 'ignore_below' and 'ignore_above'
   ;  are provided and different if there may be missing values in the input
   ;  positional parameter series:
      IF (missing AND (ignore_below EQ ignore_above)) THEN BEGIN
         error_code = 120
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': The input keyword parameter missing is set and the input ' + $
            'keyword parameters ignore_below and ignore_above are identical.'
         RETURN, error_code
      ENDIF

   ;  Return to the calling routine with an error message if the input
   ;  positional parameter 'series' does not contain at least 3 valid values:
      IF (missing) THEN BEGIN
         idx = WHERE((series GE ignore_below) AND (series LE ignore_above), $
            n_valid)
      ENDIF ELSE BEGIN
         n_valid = N_ELEMENTS(series)
      ENDELSE
      IF (n_valid LT 3) THEN BEGIN
         error_code = 130
         excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
            ': The input positional parameter series does not contain at ' + $
            'least 3 valid values.'
         RETURN, error_code
      ENDIF
   ENDIF

   ;  Evaluate the number of elements in the input positional parameter series:
   n_pts = N_ELEMENTS(series)

   ;  Initialize the flag indicating whether the previous value was
   ;  valid (1) or invalid (0):
   isval = 0

   ;  Initialize the trend indicator:
   trend = 0

   ;  Main loop:
   FOR i = 0, (n_pts - 1) DO BEGIN

   ;  Inspect whether the current value is valid:
      IF ((series[i] GE ignore_below) AND $
         (series[i] LE ignore_above)) THEN BEGIN

   ;  Current value is valid; now check whether this is the start of a
   ;  new sequence of valid values:
         IF (isval NE 1) THEN BEGIN
            isval = 1
            n_seqs = n_seqs + 1
         ENDIF ELSE BEGIN

   ;  Current value is valid and follows previous valid value; now check
   ;  whether the trend is changing:
            CASE trend OF
               -1: BEGIN
                  IF (series[i] GT series[i - 1]) THEN BEGIN
                     trend = 1
                     n_maxs = n_maxs + 1
                  ENDIF
               END
   ;  If no trend was previously set, define one if appropriate and increase
   ;  the counters for the number of minima or maxima:
               0: BEGIN
                  IF (series[i] GT series[i - 1]) THEN BEGIN
                     trend = 1
                     n_mins = n_mins + 1
                     n_maxs = n_maxs + 1
                  ENDIF
                  IF (series[i] LT series[i - 1]) THEN BEGIN
                     trend = -1
                     n_mins = n_mins + 1
                     n_maxs = n_maxs + 1
                  ENDIF
               END
   ;  Current value is valid and follows previous valid value; if the
   ;  previous trend was positive, check whether it has changed:
               1: BEGIN
                  IF (series[i] LT series[i - 1]) THEN BEGIN
                     trend = -1
                     n_mins = n_mins + 1
                  ENDIF
               END
            ENDCASE
         ENDELSE
      ENDIF ELSE BEGIN

   ;  Current value is invalid, reset the trend indicator to 0:
         isval = 0
         trend = 0
      ENDELSE
   ENDFOR

   ;  If no sequence of valid values was found, return with an error code:
   IF (n_seqs EQ 0) THEN BEGIN
      error_code = 200
      excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
         ': The input positional parameter series does not contain at ' + $
         'least 1 sequence of at least 1 valid value.'
      RETURN, error_code
   ENDIF

   ;  If no minimum or maximum was found (as could happen in a series of
   ;  single valid values separated from each other by missing values, or
   ;  with a constant signal), return with an error code:
   IF ((n_mins EQ 0) OR (n_maxs EQ 0)) THEN BEGIN
      error_code = 210
      excpt_cond = 'Error ' + strstr(error_code) + ' in ' + rout_name + $
         ': No minimum or no maximum was found in the input positional ' + $
         'parameter series.'
      RETURN, error_code
   ENDIF

   ;  Now that the number of local minima and maxima is known and
   ;  non-zero, define output arrays of the appropriate dimensions to
   ;  contain the values and time indices of these minima and maxima:
   mins = FLTARR(n_mins)
   maxs = FLTARR(n_maxs)
   i_mins = LONARR(n_mins)
   i_maxs = LONARR(n_maxs)

   ;  Reset all the counters:
   n_seqs = 0
   n_mins = 0
   n_maxs = 0
   isval = 0
   trend = 0

   ;  Re-execute the main loop and store the values and positions of the
   ;  minima and maxima along the way:
   FOR i = 0, (n_pts - 1) DO BEGIN

   ;  Inspect whether the current value is valid:
      IF ((series[i] GE ignore_below) AND $
         (series[i] LE ignore_above)) THEN BEGIN

   ;  Current value is valid; now check whether this is the start of a
   ;  new sequence of valid values, and if so set the flags to indicate
   ;  that no minima and maxima have been found yet:
         IF (isval NE 1) THEN BEGIN
            isval = 1
            n_seqs = n_seqs + 1
         ENDIF ELSE BEGIN

   ;  Current value is valid and follows at least 1 previous valid value;
   ;  now check whether the trend is changing. If trend was not
   ;  previously set, define one if appropriate and increase the counters
   ;  for the number of minima or maxima:
            IF (trend EQ 0) THEN BEGIN
               IF (series[i] GT series[i - 1]) THEN BEGIN
                  trend = 1
                  n_mins = n_mins + 1
                  n_maxs = n_maxs + 1
                  mins[n_mins - 1] = series[i - 1]
                  i_mins[n_mins - 1] = i - 1
               ENDIF
               IF (series[i] LT series[i - 1]) THEN BEGIN
                  trend = -1
                  n_mins = n_mins + 1
                  n_maxs = n_maxs + 1
                  maxs[n_maxs - 1] = series[i - 1]
                  i_maxs[n_maxs - 1] = i - 1
               ENDIF

   ;  Note that if series[i] EQ series[i - 1], the trend remains 0 and
   ;  no new minima or maxima are expected.
            ENDIF

   ;  Current value is valid and follows at least 2 previous valid
   ;  values, since trend was already set.
   ;  If the previous trend was positive but is now going down, a local
   ;  maximum has been found and a new local minimum is implied:
            IF (trend EQ 1) THEN BEGIN
               IF (series[i] LT series[i - 1]) THEN BEGIN
                  trend = -1
                  maxs[n_maxs - 1] = series[i - 1]
                  i_maxs[n_maxs - 1] = i - 1
                  n_mins = n_mins + 1
               ENDIF
            ENDIF

   ;  If the previous trend was negative but is now going up, a local
   ;  minimum has been found and a new local maximum is implied:
            IF (trend EQ -1) THEN BEGIN
               IF (series[i] GT series[i - 1]) THEN BEGIN
                  trend = 1
                  mins[n_mins - 1] = series[i - 1]
                  i_mins[n_mins - 1] = i - 1
                  n_maxs = n_maxs + 1
               ENDIF
            ENDIF

   ;  Treat the special case of a valid value at the end of the series:
            IF (i EQ n_pts - 1) THEN BEGIN
               IF (trend EQ -1) THEN BEGIN
                  mins[n_mins - 1] = series[i]
                  i_mins[n_mins - 1] = i
               ENDIF
               IF (trend EQ 1) THEN BEGIN
                  maxs[n_maxs - 1] = series[i]
                  i_maxs[n_maxs - 1] = i
               ENDIF

            ENDIF

         ENDELSE
      ENDIF ELSE BEGIN

   ;  Current value is invalid (missing); now check whether this is the
   ;  end of a sequence of valid values, and if so save the previous
   ;  valid value as a minimum or a maximum, as appropriate:
         IF (isval NE 0) THEN BEGIN

   ;  If trend was previously set and negative, the last valid value was
   ;  a local minimum:
            IF (trend EQ -1) THEN BEGIN
               mins[n_mins - 1] = series[i - 1]
               i_mins[n_mins - 1] = i - 1
            ENDIF

   ;  If trend was previously set and positive, the last valid value was
   ;  a local maximum:
            IF (trend EQ 1) THEN BEGIN
               maxs[n_maxs - 1] = series[i - 1]
               i_maxs[n_maxs - 1] = i - 1
            ENDIF

   ;  Reset the valid values and trend flags:
            isval = 0
            trend = 0
         ENDIF
      ENDELSE
   ENDFOR

   RETURN, return_code

END
