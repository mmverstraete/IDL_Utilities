<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
   <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>Documentation for the IDL routines in project Utilities</title>
   </head>
<body>
<h1>Documentation for the IDL routines in project Utilities</h1>
<ul>
<li><p><strong>Intellectual property rights</strong></p>
<ul>
<li><p>Copyright (C) 2017-2020 Michel M. Verstraete.</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following three conditions:</p>
<p>1. The above copyright notice and this permission notice shall be included in their entirety in all copies or substantial portions of the Software.</p>
<p>2. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<p>See: <a href="https://opensource.org/licenses/MIT" class="uri">https://opensource.org/licenses/MIT</a>.</p>
<p>3. The current version of this Software is freely available from</p>
<p><a href="https://github.com/mmverstraete" class="uri">https://github.com/mmverstraete</a>.</p></li>
<li><p>Feedback</p>
<p>Please send comments and suggestions to the author at<br />
<a href="mailto:MMVerstraete@gmail.com">MMVerstraete@gmail.com</a></p></li>
</ul></li>
</ul>
<h2>alogb</h2>
<ul>
<li><p><strong>Purpose:</strong> This function returns the logarithm of the input positional parameter <code>arg</code> to an arbitrary base <code>base</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function computes the logarithm of a strictly positive numeric (but not complex) scalar or array <code>arg</code> to an arbitrary but strictly positive numeric (but not complex and different from 1.0) scalar <code>base</code> as follows:<br />
log(arg, base) = log(arg, 10) / log(base, 10),<br />
where both <code>arg</code> and <code>base</code> are strictly positive.</p></li>
<li><p><strong>Syntax:</strong> <code>res = alogb(arg, base, DOUBLE = double, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg {Number} [I]:</code> An arbitrary but strictly positive numeric (not complex) scalar or array.</p></li>
<li><p><code>base {Number} [I]:</code> An arbitrary but strictly positive numeric (not complex) scalar or array, different from 1.0.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DOUBLE = double {INT} [I] (Default value: 0):</code> Flag to request computation in <code>DOUBLE</code> (<code>1</code>) or single (<code>0</code>) precision.</p></li>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>FLOAT</code> scalar or array, <code>DOUBLE</code> scalar or array, or <code>NaN</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns the following result, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided:</p>
<ul>
<li><p>If <code>arg</code> is an array and <code>base</code> is a scalar, then the logarithm of each element of <code>arg</code> is computed in base <code>base</code>.</p></li>
<li><p>If <code>arg</code> is a scalar and <code>base</code> is an array, then the logarithm of <code>arg</code> is computed in each element of base <code>base</code>.</p></li>
<li><p>If <code>arg</code> and <code>base</code> are both arrays, the logarithm of each element <code>i</code> of <code>arg</code> is computed in the corresponding element <code>i</code> of <code>base</code>. And in that case, if these arrays are of different sizes, the computation stops as soon as all elements of the shorter array have been processed.</p></li>
</ul></li>
<li><p>If an exception condition has been detected, this function returns <code>NaN</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>arg</code> is not of numeric type.</p></li>
<li><p>Error 120: Positional parameter <code>base</code> is not of numeric type.</p></li>
<li><p>Error 130: Positional parameters <code>arg</code> and/or <code>base</code> cannot be of type <code>COMPLEX</code> or <code>DCOMPLEX</code>.</p></li>
<li><p>Error 140: Positional parameter <code>arg</code> is a scalar not strictly positive.</p></li>
<li><p>Error 150: Positional parameter <code>arg</code> is an array with at least one element not strictly positive.</p></li>
<li><p>Error 160: Positional parameter <code>base</code> cannot be an array.</p></li>
<li><p>Error 170: Positional parameter <code>base</code> is not strictly positive.</p></li>
<li><p>Error 180: Positional parameter <code>base</code> cannot be equal to 1.0.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_array.pro</code></p></li>
<li><p><code>is_complex.pro</code></p></li>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The input positional parameters <code>arg</code> and <code>base</code> can be provided in any positive numeric type other than <code>COMPLEX</code> or <code>DCOMPLEX</code>, but the returned result will always be of type <code>FLOAT</code> or <code>DOUBLE</code>.</p></li>
<li><p><strong>Note 2:</strong> The input positional parameter <code>arg</code> may be an array, but the input positional parameter <code>base</code> must be a scalar.</p></li>
<li><p><strong>Note 3:</strong> The function returns <code>NaN</code> if either input positional parameter is not a strictly positive number.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = 100.0
IDL&gt; res = alogb(a, 10)
IDL&gt; PRINT, res
      2.00000

IDL&gt; res = alogb(a, 5, DOUBLE = 1, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
       2.8613531
IDL&gt; PRINT, 5^res
       100.00000

IDL&gt; res = alogb(a, EXP(1.0), DOUBLE = 0)
IDL&gt; PRINT, res
       4.6051704
IDL&gt; PRINT, EXP(4.60517)
      100.000

IDL&gt; res = alogb(-1.0, 10, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
          NaN
IDL&gt; PRINT, excpt_cond
Error 140 in ALOGB: Input positional parameter arg
   is a scalar not strictly positive.

IDL&gt; res = alogb([10.0, 100.0, 1000.0], 10, DOUBLE = 0)
IDL&gt; PRINT, &#39;res = &#39;, res
res =       1.00000      2.00000      3.00000</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p><a href="https://en.wikipedia.org/wiki/Logarithm" class="uri">https://en.wikipedia.org/wiki/Logarithm</a>, accessed 3 Jan 2018.</p></li>
<li><p><a href="https://en.wikipedia.org/wiki/Complex_logarithm" class="uri">https://en.wikipedia.org/wiki/Complex_logarithm</a>, accessed 3 Jan 2018.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;02&#8211;24: Version 2.01 &#8212; Documentation update.</p></li>
<li><p>2019&#8211;06&#8211;19: Version 2.02 &#8212; Prevent the input positional parameter <code>base</code> from being an array.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
<li><p>2019&#8211;10&#8211;05: Version 2.1.1 &#8212; Update the code to make use of the internal variable <code>return_code</code>.</p></li>
</ul></li>
</ul>
<h2>autocorr</h2>
<ul>
<li><p><strong>Purpose:</strong> This function computes the autocovariance and autocorrelation statistics on a series that may contain an arbitrary number of missing values arbitrarily distributed within the series.</p></li>
<li><p><strong>Algorithm:</strong> This function computes the arithmetic mean, variance, autocovariance and autocorrelation statistics for all values of a series that lie between <code>ignore_below</code> and <code>ignore_above</code>. In the statistical literature, the normalization of the autocorrelation is typically done by dividing the sum of the products by the number of elements in the original series (thus ignoring the presence of missing values) or by that number minus the lag, to account for the smaller number of pairs of points contributing to the covariance at larger lags. Here, the normalization is made by the number of valid values in the series. This matches the convention used in IDL&#8217;s own function <code>A_CORRELATE</code> and the recommendations of Datta and Du (2012) [See the References section below].</p></li>
<li><p><strong>Syntax:</strong> <code>rc = autocorr(series, lags, ignore_below, ignore_above, $</code><br />
<code>nval, armean, var, ncv, cov, cor, $</code><br />
<code>VERBOSE = verbose, DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>series {FLOAT array} [I]:</code> The series of values to be analyzed.</p></li>
<li><p><code>lags {INT array} [I]:</code> The lags to consider.</p></li>
<li><p><code>ignore_below {FLOAT} [I]:</code> The threshold below which values in <code>series</code> should be ignored.</p></li>
<li><p><code>ignore_above {FLOAT} [I]:</code> The threshold above which values in <code>series</code> should be ignored.</p></li>
<li><p><code>nval {LONG} [O]:</code> The number of valid values in <code>series</code>.</p></li>
<li><p><code>armean {FLOAT} [O]:</code> The arithmetic mean of the valid values in <code>series</code>.</p></li>
<li><p><code>var {FLOAT} [O]:</code> The variance of the valid values in <code>series</code>.</p></li>
<li><p><code>ncv {INT array} [O]:</code> The number of pairs of valid values in <code>series</code> contributing to the autocovariance and autocorrelation functions at each of the lags: this value is not used in the computation but may serves as an empirical diagnostic of the reliability of those functions.</p></li>
<li><p><code>cov {FLOAT array} [O]:</code> The autocovariances of the <code>series</code> at the specified <code>lags</code>.</p></li>
<li><p><code>cor {FLOAT array} [O]:</code> The autocorrelations of the <code>series</code> at the specified <code>lags</code>.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>VERBOSE = verbose {INT} [I] (Default value: 0):</code> Flag to enable (&gt; 0) or skip (0) outputting messages on the console:</p>
<ul>
<li><p>If <code>verbose &gt; 0</code>, messages inform the user about progress in the execution of time-consuming routines, or the location of output files (e.g., log, map, plot, etc.);</p></li>
<li><p>If <code>verbose &gt; 1</code>, messages record entering and exiting the routine; and</p></li>
<li><p>If <code>verbose &gt; 2</code>, messages provide additional information about intermediary results.</p></li>
</ul></li>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided in the call. The output positional parameters contain the results generated by this function.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameters may be incomplete or incorrect.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Warning 98: The computer has not been recognized by the function<br />
<code>get_host_info.pro</code>.</p></li>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: The input positional parameter <code>misr_mode</code> is invalid.</p></li>
<li><p>Error 120: The input positional parameter <code>misr_path</code> is invalid.</p></li>
<li><p>Error 130: The input positional parameter <code>misr_orbit</code> is invalid.</p></li>
<li><p>Error 132: The input positional parameter <code>misr_orbit</code> is inconsistent with the input positional parameter <code>misr_path</code>.</p></li>
<li><p>Error 134: An exception condition occurred in <code>is_frompath.pro</code>.</p></li>
<li><p>Error 136: Unexpected return code received from <code>is_frompath.pro</code>.</p></li>
<li><p>Error 140: The input positional parameter <code>misr_block</code> is invalid.</p></li>
<li><p>Error 199: An exception condition occurred in <code>set_roots_vers.pro</code>.</p></li>
<li><p>Error 200: An exception condition occurred in function <code>path2str.pro</code>.</p></li>
<li><p>Error 210: An exception condition occurred in function <code>orbit2str.pro</code>.</p></li>
<li><p>Error 220: An exception condition occurred in function <code>block2str.pro</code>.</p></li>
<li><p>Error 230: An exception condition occurred in function <code>orbit2date.pro</code>.</p></li>
<li><p>Error 299: The computer is not recognized and at least one of the optional input keyword parameters <code>l1b2_folder</code>, ..., <code>map_folder</code> is not specified.</p></li>
<li><p>Error 300: The input folder <code>l1b2_path</code> is unreadable.</p></li>
<li><p>Error 400: The output folder <code>log_path</code> is unwritable.</p></li>
<li><p>Error 500: An exception condition occurred in function <code>fname.pro</code>.</p></li>
<li><p>Error 600: An exception condition occurred in the <span class="smallcaps">MISR</span> <span class="smallcaps">Toolkit</span> routine<br />
<code>MTK_SETREGION_BY_PATH_BLOCKRANGE</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>MISR Toolkit</code></p></li>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The computations are carried out in <code>DOUBLE</code> precision.</p></li>
<li><p><strong>Note 2:</strong> The autocovariance at lag <code>l</code> is set to <code>-999.0</code> if there are fewer than <code>2</code> valid values.</p></li>
<li><p><strong>Note 3:</strong> The autocorrelation at lag <code>l</code> is set to <code>-999.0</code> if the autocovariance at that lag is negative or if the variance of the entire series of valid values is null.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; series = [3.73, 3.67, 3.77, 3.83, 4.67, $
   5.87, 6.70, 6.97, 6.40, 5.57]
IDL&gt; lags = [-3, 0, 1, 3, 4, 8]
IDL&gt; ignore_below = -10.0
IDL&gt; ignore_above = 10.0
IDL&gt; rc = autocorr(series, lags, ignore_below, $
   ignore_above, nval, armean, var, ncv, cov, cor, $
   VERBOSE = verbose, DEBUG = debug, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;cov = &#39;, cov
cov =  0.023456856  1.6045959  1.3011335  0.023456856
   -0.52194154  -0.24339123
IDL&gt; PRINT, &#39;cor = &#39;, cor
cor =  0.014618544  1.0000000  0.81087926  0.014618544
   -0.32527912  -0.15168382</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p>Box, G. and G. Jenkins (1976) &#8217;Time Series Analysis&#8217;, Holden-Day.</p></li>
<li><p>Fuller, W. (1976) &#8217;Introduction to Statistical Time Series&#8217;, Wiley.</p></li>
<li><p>Datta, D. D. and Du, W. (2012) &#8217;Nonparametric HAC Estimation for Time Sereis Data with Missing Observations&#8217;, Board of Governots of the Federal Reserve System, International Finance Discussion Papers number 1060, available from <code>https://www.federalreserve.gov/pubs/ifdp/2012/1060/ifdp1060.htm</code>, accessed on 11 October 2019.</p></li>
<li><p>URL: <code>http://en.wikipedia.org/wiki/Autocorrelation</code>, first accessed on 18 February 2007, and again on 11 October 2019.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2007&#8211;02&#8211;18: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;10&#8211;12: Version 2.1.0 &#8212; Adopt revised coding and documentation standards, and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>caldate</h2>
<ul>
<li><p><strong>Purpose:</strong> This function takes a Julian date as input and computes the corresponding calendar year, month and day. The date, formatted as a <code>YYYY-MM-DD</code> is available in the optional output keyword parameter <code>DATE</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function is a convenient wrapper to the <code>IDL</code> program <code>CALDAT</code>.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = caldate(jdate, year, month, day, DATE = date, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>jdate {LONG or DOUBLE} [I]:</code> The Julian date.</p></li>
<li><p><code>year {INT} [O]:</code> The corresponding calendar year number.</p></li>
<li><p><code>month {INT} [O]:</code> The corresponding calendar month number.</p></li>
<li><p><code>day {INT} [O]:</code> The corresponding calendar day number.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DATE = date {STRING} [O]:</code> The corresponding date expressed as a <code>STRING</code> formatted as <code>yyyy-mm-dd</code>.</p></li>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided in the call. The output positional parameters contain the results generated by this function.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameters may be undefined (for parameters), incomplete or incorrect.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: The input positional parameter <code>jdate</code> must be either a <code>LONG</code> or a <code>DOUBLE</code> number.</p></li>
<li><p>Error 120: The input positional parameter <code>jdate</code> must be positive.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_double.pro</code></p></li>
<li><p><code>is_long.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function returns the calendar information in the order <code>year</code>, <code>month</code>, <code>day</code>, rather than order of the <code>CALDAT</code> program, which is <code>month</code>, <code>day</code>, <code>year</code>.</p></li>
<li><p><strong>Note 2:</strong> The input positional parameter <code>jdate</code> can be a scalar or an array.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; jdate = 2458606L
IDL&gt; rc = caldate(jdate, year, month, day, DATE = date)
IDL&gt; PRINT, &#39;date = &#39; + date
date = 2019-05-02

IDL&gt; jdate = 2458606.12345D
IDL&gt; rc = caldate(jdate, year, month, day, DATE = date,
   HOUR = hour, MINUTE = minute, SECOND = second)
IDL&gt; PRINT, &#39;date = &#39; + date
date = 2019-05-02
IDL&gt; PRINT, hour, minute, second
          14          57       46.079986

IDL&gt; jdate = [2458606, 2458607]
IDL&gt; rc = caldate(jdate, year, month, day, DATE = date)
IDL&gt; PRINT, date
2019-05-02 2019-05-03</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2014&#8211;06&#8211;13: Version 1.0 &#8212; Initial release by Linda Hunt.</p></li>
<li><p>2019&#8211;05&#8211;02: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;06&#8211;12: Version 2.01 &#8212; Update the documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>chk_isodate</h2>
<ul>
<li><p><strong>Purpose:</strong> This function checks the validity of the scalar input positional parameter <code>isodate</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function verifies that the input positional parameter <code>isodate</code> is a scalar <code>STRING</code> formatted as <code>yyyy-mm-ddThh:nn:ssZ</code> where</p>
<ul>
<li><p><code>yyyy</code> is a valid 4-digit year number,</p></li>
<li><p><code>mm</code> is a valid 2-digit month number,</p></li>
<li><p><code>dd</code> is a valid 2-digit day number,</p></li>
<li><p><code>hh</code> is a valid 2-digit hour number,</p></li>
<li><p><code>nn</code> is a valid 2-digit minute number, and</p></li>
<li><p><code>ss</code> is a valid 2-digit second number.</p></li>
</ul></li>
<li><p><strong>Syntax:</strong> <code>rc = chk_isodate(isodate, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>isodate {STRING} [I]:</code> A string containing a date and time specification formatted as <code>yyyy-mm-ddThh:nn:ssZ</code>.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> was set and if the optional output keyword parameter <code>EXCPT_COND</code> was provided in the call. The input positional parameter <code>isodate</code> is valid.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The input positional parameter <code>isodate</code> may be invalid.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input positional parameter <code>isodate</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 120: Input positional parameter <code>isodate</code> cannot be an array.</p></li>
<li><p>Error 200: The input positional parameter <code>isodate</code> is incorrectly formatted: it must contain 2 strings separated by <code>T</code>.</p></li>
<li><p>Error 210: The input positional parameter <code>isodate</code> is incorrectly formatted: the date must contain 3 strings separated by <code>-</code>.</p></li>
<li><p>Error 220: The input positional parameter <code>isodate</code> is incorrectly formatted: the time must contain 3 strings separated by <code>:</code>.</p></li>
<li><p>Error 230: The input positional parameter <code>isodate</code> is invalid: the year must be within the range [1582, 2100].</p></li>
<li><p>Error 240: The input positional parameter <code>isodate</code> is invalid: the month must be within the range [1, 12].</p></li>
<li><p>Error 250: An exception condition occurred in <code>days_per_month.pro</code>.</p></li>
<li><p>Error 260: The input positional parameter <code>isodate</code> is invalid: the day must be within the range [1, number of days in the month].</p></li>
<li><p>Error 270: The input positional parameter <code>isodate</code> is invalid: the hour must be within the range [0, 23].</p></li>
<li><p>Error 280: The input positional parameter <code>isodate</code> is invalid: the minute must be within the range [0, 59].</p></li>
<li><p>Error 290: The input positional parameter <code>isodate</code> is invalid: the second must be within the range [0, 59].</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>days_per_month.pro</code></p></li>
<li><p><code>is_array.pro</code></p></li>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>last_char.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> Since the purpose of this function is to check the validity of the input positional parameter <code>isodate</code>, all tests are performed irrespective of the setting of the input keyword parameter <code>DEBUG</code>. The optional input keyword <code>DEBUG</code> is included for consistency but its value on input is ignored, while the optional output keyword parameter <code>EXCPT_COND</code> allows reporting of the exception condition if one is encountered.</p></li>
<li><p><strong>Note 2:</strong> The input positional parameter <code>isodate</code> cannot be an array.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; isodate = &#39;2018-06-13T12:00:00Z&#39;
IDL&gt; rc = chk_isodate(isodate, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;rc = &#39; + strstr(rc) + &#39;, excpt_cond = &gt;&#39; + $
   excpt_cond + &#39;&lt;&#39;
rc = 0, excpt_cond = &gt;&lt;

IDL&gt; isodate = &#39;2018-06-13T32:00:00Z&#39;
IDL&gt; rc = chk_isodate(isodate, DEBUG = 0, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;rc = &#39; + strstr(rc) + &#39;, excpt_cond = &gt;&#39; + $
   excpt_cond + &#39;&lt;&#39;
rc = 270, excpt_cond = &gt;Error 270 in CHK_ISODATE: Input positional
   parameter isodate is invalid: the hour must be within the range
   [0, 23].&lt;

IDL&gt; isodate = &#39;2018-06-13T32:00:00Z&#39;
IDL&gt; rc = chk_isodate(isodate)
IDL&gt; PRINT, &#39;rc = &#39; + strstr(rc)
rc = 270</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p><a href="https://www.w3.org/TR/NOTE-datetime" class="uri">https://www.w3.org/TR/NOTE-datetime</a>, accessed on 21 November 2018.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;03&#8211;25: Version 0.9 &#8212; Initial release under the name <code>chk_date_iso.pro</code>.</p></li>
<li><p>2018&#8211;03&#8211;28: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;04&#8211;03: Version 1.1 &#8212; Updated error diagnostics.</p></li>
<li><p>2018&#8211;04&#8211;23: Version 1.2 &#8212; Bug fix (missing parenthesis on line 287).</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2018&#8211;11&#8211;23: Version 1.6 &#8212; Change the name of the routine from <code>chk_date_iso.pro</code> to <code>chk_isodate.pro</code>, remove the output positional parameter <code>julian_iso</code> and the code to compute its value, as this functionality is now available with function<br />
<code>iso2jul.pro</code>, perform all diagnostic tests irrespective of the value of the optional input keyword parameter <code>DEBUG</code>, and update the documentation.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>chk_ymddate</h2>
<ul>
<li><p><strong>Purpose:</strong> This function analyzes the <code>STRING</code> input positional parameter <code>date</code>, formatted as <code>YYYY-MM-DD</code>, and provides the <code>year</code>, <code>month</code> and <code>day</code> values as numeric output positional parameters.</p></li>
<li><p><strong>Algorithm:</strong> This function splits the input positional parameter <code>date</code> on character <code>-</code> and sets the output positional parameters <code>year</code>, <code>month</code> and <code>day</code> to their numerical values. If the input keyword parameter <code>DEBUG</code> is set, this function also checks the validity of <code>date</code> and of its 3 components: the year number <code>YYYY</code> must be larger than 1582 and smaller than 2100, the month number <code>MM</code> must be larger than 0 and smaller than 13, while the day number <code>DD</code> must be larger than 0 and smaller than the number of days in that month, accounting for the possibility of a leap year.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = chk_ymddate(date, year, month, day, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>date {STRING} [I]:</code> A string indicating a date.</p></li>
<li><p><code>year {INT} [O]:</code> The numeric year of date <code>date</code>.</p></li>
<li><p><code>month {INT} [O]:</code> The numeric month of date <code>date</code>.</p></li>
<li><p><code>day {INT} [O]:</code> The numeric day of date <code>date</code>.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> was set and if the optional output keyword parameter <code>EXCPT_COND</code> was provided in the call. The output positional parameters <code>year</code>, <code>month</code> and <code>day</code> provide the desired numeric information.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameters corresponding to invalid values are set to <code>0</code>.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>date</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 120: Positional parameter <code>date</code> is not of length 10.</p></li>
<li><p>Error 130: Positional parameter <code>date</code> cannot be an array.</p></li>
<li><p>Error 200: Positional parameter <code>date</code> does not contain a dash character.</p></li>
<li><p>Error 210: Positional parameter <code>date</code> does not contain 2 dash characters.</p></li>
<li><p>Error 220: Positional parameter <code>date</code> does not contain 3 elements separated by 2 dashes.</p></li>
<li><p>Error 230: Positional parameter <code>date</code> specifies an invalid year.</p></li>
<li><p>Error 240: Positional parameter <code>date</code> specifies an invalid month.</p></li>
<li><p>Error 250: An exception condition occurred in <code>days_per_month.pro</code>.</p></li>
<li><p>Error 260: Positional parameter <code>date</code> specifies an invalid day.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>days_per_month.pro</code></p></li>
<li><p><code>is_array.pro</code></p></li>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> Since the purpose of this function is to check the validity of the input positional parameter <code>date</code>, all tests are performed irrespective of the setting of the input keyword parameter <code>DEBUG</code>. The optional input keyword <code>DEBUG</code> is included for consistency but its value on input is ignored, while the optional output keyword parameter <code>EXCPT_COND</code> allows reporting of the exception condition if one is encountered.</p></li>
<li><p><strong>Note 2:</strong> The input positional parameter <code>date</code> cannot be an array.</p></li>
<li><p><strong>Note 3:</strong> The month and day elements of the input positional parameter <code>date</code> must be 0-filled to make up a 10-character long string; hence a date like 5 Feb 2011 must be provided as <code>2011-02-05</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; rc = chk_ymddate(&#39;2010-01-01&#39;, year, month, day, $
   DEBUG = 1, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, rc, &#39;   &gt;&#39; + excpt_cond + &#39;&lt;&#39;
       0   &gt;&lt;
IDL&gt; PRINT, year, month, day
    2010       1       1

IDL&gt; rc = chk_ymddate(&#39;2200-01-01&#39;, year, month, day, $
   DEBUG = 1, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, rc, &#39;   &gt;&#39; + excpt_cond + &#39;&lt;&#39;
     230   &gt;Error 230 in CHK_YMDDATE: Year 2200 is invalid
      (must be 4 digits long and lie within [1582, 2100]).&lt;

IDL&gt; rc = chk_ymddate(&#39;1999-02-29&#39;, year, month, day, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, rc, &#39;   &gt;&#39; + excpt_cond + &#39;&lt;&#39;
     260   &gt;Error 260 in CHK_YMDDATE: Day 29 is invalid
     (must be 2 digits long and lie within
     [1, #days in the month]).&lt;
IDL&gt; PRINT, year, month, day
    1999       2       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;09&#8211;07: Version 0.9 &#8212; Initial release under the name <code>chk_date_ymd.pro</code>.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;03&#8211;28: Version 1.2 &#8212; Update the code to use the new function<br />
<code>days_per_month.pro</code>.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2018&#8211;12&#8211;13: Version 1.6 &#8212; Rename this function to <code>chk_ymddate.pro</code>.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>cor_arrays</h2>
<ul>
<li><p><strong>Purpose:</strong> This function computes various statistics to describe the possible relations between two arrays containing the same number of data points. The results are stored in the pre-existing output structure <code>stats</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on <code>IDL</code> built-in routines to compute the desired statistics.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = cor_arrays(array_1, array_2, stats, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>array_1 {FLOAT array} [I]:</code> The first array to consider.</p></li>
<li><p><code>array_2 {FLOAT array} [I]:</code> The second array to consider.</p></li>
<li><p><code>stats {STRUCTURE} [I/O]:</code> A pre-existing structure to hold the statistical results, organized as follows:</p>
<pre><code>stats = CREATE_STRUCT(NAME = &#39;Bivariate&#39;, $
   &#39;experiment&#39;, 0, $
   &#39;array_1_id&#39;, &#39;&#39;, $
   &#39;array_2_id&#39;, &#39;&#39;, $
   &#39;N_points&#39;, 0L, $
   &#39;RMSD&#39;, 0.0, $
   &#39;Pearson_cc&#39;, 0.0, $
   &#39;Spearman_cc&#39;, 0.0, $
   &#39;Spearman_sig&#39;, 0.0, $
   &#39;Spearman_D&#39;, 0.0, $
   &#39;Spearman_PROBD&#39;, 0.0, $
   &#39;Spearman_ZD&#39;, 0.0, $
   &#39;Linear_fit_1&#39;, &#39;&#39;, $
   &#39;Linfit_a_1&#39;, 0.0, $
   &#39;Linfit_b_1&#39;, 0.0, $
   &#39;Linfit_CHISQR_1&#39;, 0.0, $
   &#39;Linfit_PROB_1&#39;, 0.0, $
   &#39;Linear_fit_2&#39;, &#39;&#39;, $
   &#39;Linfit_a_2&#39;, 0.0, $
   &#39;Linfit_b_2&#39;, 0.0, $
   &#39;Linfit_CHISQR_2&#39;, 0.0, $
   &#39;Linfit_PROB_2&#39;, 0.0)</code></pre></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> was set and if the optional output keyword parameter <code>EXCPT_COND</code> was provided in the call. The desired statistics are contained in the output structure <code>stats</code>.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output structure may be empty, incomplete or useless.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>array_1</code> or <code>array_2</code> is not of type numeric.</p></li>
<li><p>Error 120: Positional parameter <code>array_1</code> or <code>array_2</code> is not an array.</p></li>
<li><p>Error 130: Positional parameter <code>array_1</code> and <code>array_2</code> are of different sizes.</p></li>
<li><p>Error 140: Positional parameter <code>array_1</code> and <code>array_2</code> contain fewer than 5 elements.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The structure elements <code>experiment</code>, <code>array_1_id</code> and <code>array_2_id</code> are intended to contain a numeric identifier for the experiment and descriptors of these two positional parameters. These should be set prior to calling this function.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; stats = CREATE_STRUCT(NAME = &#39;Bivariate&#39;, $
IDL&gt;    &#39;experiment&#39;, 0, $
IDL&gt;    &#39;array_1_id&#39;, &#39;&#39;, $
IDL&gt;    &#39;array_2_id&#39;, &#39;&#39;, $
IDL&gt;    &#39;N_points&#39;, 0L, $
IDL&gt;    &#39;RMSD&#39;, 0.0, $
IDL&gt;    &#39;Pearson_cc&#39;, 0.0, $
IDL&gt;    &#39;Spearman_cc&#39;, 0.0, $
IDL&gt;    &#39;Spearman_sig&#39;, 0.0, $
IDL&gt;    &#39;Spearman_D&#39;, 0.0, $
IDL&gt;    &#39;Spearman_PROBD&#39;, 0.0, $
IDL&gt;    &#39;Spearman_ZD&#39;, 0.0, $
IDL&gt;    &#39;Linear_fit_1&#39;, &#39;&#39;, $
IDL&gt;    &#39;Linfit_a_1&#39;, 0.0, $
IDL&gt;    &#39;Linfit_b_1&#39;, 0.0, $
IDL&gt;    &#39;Linfit_CHISQR_1&#39;, 0.0, $
IDL&gt;    &#39;Linfit_PROB_1&#39;, 0.0, $
IDL&gt;    &#39;Linear_fit_2&#39;, &#39;&#39;, $
IDL&gt;    &#39;Linfit_a_2&#39;, 0.0, $
IDL&gt;    &#39;Linfit_b_2&#39;, 0.0, $
IDL&gt;    &#39;Linfit_CHISQR_2&#39;, 0.0, $
IDL&gt;    &#39;Linfit_PROB_2&#39;, 0.0)
IDL&gt; x1 = [65,63,67,64,68,62,70,66,68,67,69,71]
IDL&gt; y1 = [68,66,68,65,69,66,68,65,71,67,68,70]
IDL&gt; stats.experiment = 1
IDL&gt; stats.array_1_id = &#39;x1&#39;
IDL&gt; stats.array_2_id = &#39;y1&#39;
IDL&gt; rc = cor_arrays(x1, y1, stats, /DEBUG, $
IDL&gt;    EXCPT_COND = excpt_cond)
IDL&gt; fmt = &#39;(A20, A)&#39;
IDL&gt; PRINT, &#39;N_points = &#39;, strstr(stats.N_points), FORMAT = fmt
      N_points = 12
IDL&gt; PRINT, &#39;RMSD = &#39;, strstr(stats.RMSD), FORMAT = fmt
      RMSD = 2.10159
...
IDL&gt; PRINT, &#39;Linear_fit_2 = &#39;, strstr(stats.Linear_fit_2), $
IDL&gt;    FORMAT = fmt
     Linear_fit_2 = array_1 = a + b x array_2
IDL&gt; PRINT, &#39;Linfit_a_2 = &#39;, strstr(stats.Linfit_a_2), $
IDL&gt;    FORMAT = fmt
     Linfit_a_2 = -3.37687
...</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;02&#8211;28: Version 0.8 &#8212; Initial release under the name <code>cor_fields</code>.</p></li>
<li><p>2017&#8211;07&#8211;20: Version 0.9 &#8212; Renamed function to <code>cor_arrays</code>, removed any reference to <span class="smallcaps">MISR</span> or <span class="smallcaps">MISR-HR</span> (generic utility routine), updated documentation.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
<li><p>2020&#8211;03&#8211;05: Version 2.1.1 &#8212; Add a test on the input data arrays to ensure they contain at least 5 elements.</p></li>
</ul></li>
</ul>
<h2>count_code_lines</h2>
<ul>
<li><p><strong>Purpose:</strong> This function returns the approximate number of code lines (as a <code>LONG</code> integer) contained in the text file specified by the input positional parameter <code>file_spec</code>, i.e., the number of lines that are neither blank (empty) nor beginning with a string expression contained in <code>comm_char</code> denoting the start of a comment.</p></li>
<li><p><strong>Algorithm:</strong> This function inspects each and every line of <code>file_spec</code> and counts those that are neither empty nor starting with one of the string(s) provided in <code>comm_char</code>. Blank space (space, TAB) at the start of the line is ignored for this purpose. The <code>STRING</code> variable <code>comm_char</code> can be either a constant or an array, in which case all elements of that array are used in succession to check all possible options. Each element of <code>comm_char</code> can include multiple characters (e.g., to deal with <code>C</code> or <code>PL-1</code> language conventions such as /* comment */).</p></li>
<li><p><strong>Syntax:</strong> <code>res = count_code_lines(file_spec, comm_char, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>file_spec {STRING} [I]:</code> The file specification (optional path and name) of the text file to inspect.</p></li>
<li><p><code>comm_char {STRING or STRING array} [I]:</code> One (scalar) or more (if array) string expression(s) containing the usual characters to indicate comments in computer languages.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>LONG</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns the approximate number of code lines in <code>file_spec</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns <code>-1L</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>file_spec</code> is not of type STRING.</p></li>
<li><p>Error 120: Positional parameter <code>file_spec</code> is not a scalar.</p></li>
<li><p>Error 130: Positional parameter <code>file_spec</code> is not found, not a regular file or not readable.</p></li>
<li><p>Error 140: Positional parameter <code>comm_char</code> is not of type <code>STRING</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_array.pro</code></p></li>
<li><p><code>is_scalar.pro</code></p></li>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The <code>IDL</code> built-in command <code>FILE_LINES</code> counts and returns the total number of lines in a text file. By contrast, the function <code>count_code_lines</code> reports on the number of active or effective code lines, i.e., without counting comments and empty lines.</p></li>
<li><p><strong>Note 2:</strong> The <code>STRING</code> variable <code>comm_char</code> can be either a scalar or an array, in which case all elements of that array are used in succession to check all possible options. Each element of <code>comm_char</code> can include multiple characters (e.g., to deal with <code>C</code> or <code>PL-1</code> language conventions such as <code>/* comment */</code>). And if <code>comm_char</code> is set to a scalar null string, this function returns the total number of lines in the file, as reported by <code>FILE_LINES</code>.</p></li>
<li><p><strong>Note 3:</strong> This routine may not yield the correct number of code lines if comments span multiple lines, each terminated by a <code>&lt;CR&gt;</code> and/or <code>&lt;LF&gt;</code>, without repeating the commenting character sequence on each line. However, a comment written on a single long line, which may appear on multiple lines on screen due to soft wrapping, would be treated correctly.</p></li>
<li><p><strong>Note 4:</strong> This function is also usable in other contexts that use a character string at the start of a line to indicate comments, such as in LaTeX, for instance.</p></li>
<li><p><strong>Note 5:</strong> If the input positional parameter <code>comm_char</code> is the scalar empty string <code>&#8221;</code>, then this function returns the number of lines provided by the IDL function <code>FILE_LINES.</code></p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; file_spec = &#39;./Codes/IDL/Utilities/is_leap/is_leap.pro&#39;
IDL&gt; PRINT, FILE_LINES(file_spec)
                   208
IDL&gt; PRINT, count_code_lines(file_spec, &#39;;&#39;, $
   DEBUG = 1, EXCPT_COND = excpt_cond)
          49</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;05&#8211;17: Version 2.01 &#8212; Code simplification (<code>FILE_TEST</code>).</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
<li><p>2019&#8211;10&#8211;10: Version 2.1.1 &#8212; Update the documentation to indicate that this function returns the value provided by <code>FILE_TEST</code> whenever the input positional parameter <code>comm_char</code> is set to a null string.</p></li>
</ul></li>
</ul>
<h2>date_of_year</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports the date corresponding to the rank number <code>day_of_year</code> provided as input.</p></li>
<li><p><strong>Algorithm:</strong> This function computes the date (month and day) corresponding to the rank (day number within a civil year) provided as input, either for a common year (if the keyword parameter <code>YEAR</code> is not specified), or for that particular year if it is.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = date_of_year(day_of_year, month, day, $</code><br />
<code>YEAR = year, DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>day_of_year {INT} [I]:</code> The rank (day number) of a day in a year, a value expected to be in the range [1, 365] for a common year, or [1, 366] for a leap year.</p></li>
<li><p><code>month {INT} [O]:</code> The month in which this day falls.</p></li>
<li><p><code>day {INT} [O]:</code> The day within that month.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>YEAR = year {INT} [I] (Default: None):</code> The optional year number.</p></li>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> was set and if the optional output keyword parameter <code>EXCPT_COND</code> was provided in the call. The output positional parameters <code>month</code> and <code>day</code> provide the month and day numbers corresponding to the input positional parameter <code>day_of_year</code>, for a non-leap year if the optional input keyword parameter is either absent or points to a non-leap year. If this optional input keyword parameter is present in the call and points to a leap year, the output positional parameters are specific for that year.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameters <code>month</code> and <code>day</code> are set to <code>-1</code>.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input positional parameter <code>day_of_year</code> is not of numeric type.</p></li>
<li><p>Error 120: An exception condition occurred in <code>days_per_month.pro</code>.</p></li>
<li><p>Error 130: Input positional parameter <code>day_of_year</code> is invalid.</p></li>
<li><p>Error 200: Exception condition encountered in <code>CASE</code> statement: the value of the input positional parameter <code>day_of_year</code> is invalid. Set the optional keyword parameter <code>DEBUG</code> to get a more specific diagnostic.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>days_per_month.pro</code></p></li>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function cannot test and adjust for leap year if the year is not specified, so in the absence of the input keyword parameter <code>YEAR = year</code>, or if the specified year is not a leap year, the value <code>day_of_year = 366</code> is considered in error.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; res = date_of_year(60, month, day, $
   DEBUG = 1, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;month = &#39;, month, &#39; and day = &#39;, day
month =        3 and day =        1

IDL&gt; res = date_of_year(60, month, day, YEAR = 2004, $
   DEBUG = 1, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;month = &#39;, month, &#39; and day = &#39;, day
month =        2 and day =       29</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;10: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;-11&#8211;-20: Version 1.0 &#8212;&#8211; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;04&#8211;03: Version 1.2 &#8212; Update the code to use the new function<br />
<code>days_per_month.pro</code>.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>day_of_year</h2>
<ul>
<li><p><strong>Purpose:</strong> This function computes the rank (day number) of a date specified by the <code>month</code> and <code>day</code> numbers provided as input positional parameters, either for an arbitrary common year, or for the particular year specified in the optional keyword parameter <code>year</code>.</p></li>
<li><p><strong>Algorithm:</strong> By default, this function accumulates and returns the number of days between January 1 and the date specified by the positional parameters <code>month</code> and <code>day</code>, for a common (non leap) year. If the optional keyword parameter <code>year</code> is set to a particular value, this function computes the rank of the specified date taking into account the leap status of that year.</p></li>
<li><p><strong>Syntax:</strong> <code>res = day_of_year(month, day, YEAR = year, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>month {INT} [I]:</code> The month of the date to characterize, where January is 1, February is 2, <span class="math inline">&#8230;</span> and December is 12.</p></li>
<li><p><code>day {INT} [I]:</code> The day within the month of the date to characterize, where the first day of the month is 1 and the last day of the month is either 28, 30 or 31, depending on the month.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>YEAR = year {INT} [I]:</code> The specific year for which the computation must be carried out.</p></li>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns the rank number of the specified day in a common year (if the keyword <code>year</code> was not set) or in the specified <code>year</code> (if the keyword was set), and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns <code>-1</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>month</code> is not a scalar variable of type numeric.</p></li>
<li><p>Error 120: Positional parameter <code>month</code> is invalid: Must be contained in [1, 12].</p></li>
<li><p>Error 130: Keyword parameter <code>year</code> is not a scalar variable of type numeric.</p></li>
<li><p>Error 140: Keyword parameter <code>year</code> is invalid: Must be contained within [1582, 2100].</p></li>
<li><p>Error 150: Positional parameter <code>day</code> is not a scalar variable of type numeric.</p></li>
<li><p>Error 160: Positional parameter <code>day</code> is invalid: Must be contained in the interval [1, num_days[month]].</p></li>
<li><p>Error 200: An exception condition occurred in <code>days_per_month.pro</code>.</p></li>
<li><p>Error 210: An exception condition occurred in <code>days_per_month.pro</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>days_per_month.pro</code></p></li>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>is_scalar.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> By default, this function accumulates and returns the number of days between January 1 and the date specified by the positional parameters <code>month</code> and <code>day</code>, for a common (non leap) year. If the optional keyword parameter <code>year</code> is set to a particular value, this routine computes the rank of the specified date taking into account the leap status of that <code>year</code>.</p></li>
<li><p><strong>Note 2:</strong> If <code>day</code> is set to 29 (implying a leap year), the keyword parameter <code>year</code> must be provided, otherwise the function returns an error code, provided the optional input keyword parameter <code>DEBUG</code> is set.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; res = day_of_year(3, 25, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
      84
IDL&gt; PRINT, &#39;excpt_cond = &gt;&#39; + excpt_cond + &#39;&lt;&#39;
excpt_cond = &gt;&lt;

IDL&gt; res = day_of_year(6, 13, YEAR = 2000, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
     165
IDL&gt; PRINT, &#39;excpt_cond = &gt;&#39; + excpt_cond + &#39;&lt;&#39;
excpt_cond = &gt;&lt;

IDL&gt; res = day_of_year(2, 29, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
      -1
IDL&gt; PRINT, &#39;excpt_cond = &#39; + excpt_cond
excpt_cond = Error 134 in day_of_year: Input positional parameter
   day is invalid: Must be contained in [1, num_days[month]].

IDL&gt; res = day_of_year(2, 29, YEAR = 2016, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
      60
IDL&gt; PRINT, &#39;excpt_cond = &gt;&#39; + excpt_cond + &#39;&lt;&#39;
excpt_cond = &gt;&lt;

[Note: Without the DEBUG option, the result is incorrect
(2015 is not a leap year) and the function does not report
the problem.]
IDL&gt; res = day_of_year(2, 29, YEAR = 2015, DEBUG = 0, $
   EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
      60
IDL&gt; PRINT, &#39;excpt_cond = &gt;&#39; + excpt_cond + &#39;&lt;&#39;
excpt_cond = &gt;&lt;</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>days_per_month</h2>
<ul>
<li><p><strong>Purpose:</strong> This function sets the number of days per month, for either a generic or a particular year (specified through the keyword <code>year</code>), in which case it adjusts the number of days in February if that year is a leap year.</p></li>
<li><p><strong>Algorithm:</strong> This function defines the output positional parameter <code>num_days</code> as a 13-element <code>INT</code> array, sets <code>num_days[0]</code> to 365 and assigns the default number of days to each month of the year in array elements 1 to 12. If the keyword parameter <code>year</code> is provided, the function checks whether that year is a leap year and adjusts the number of days in February as well as the total number of days in the year accordingly.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = days_per_month(num_days, YEAR = year, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>num_days {INT} [O]:</code> Array containing the number of days of each month, as well as the total number of days in the year.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>YEAR = year {INT} [I] (Default value: None):</code> Optional year number in the range [1584, 2100], for the purpose of determining if that year is a leap year.</p></li>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> was set and if the optional output keyword parameter <code>EXCPT_COND</code> was provided in the call. The output positional parameter <code>num_days</code> contains the results generated by this function.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameter <code>num_days</code> may be undefined or useless.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input keyword parameter <code>year</code> is invalid: it must be within the range [1582, 2100].</p></li>
<li><p>Error 120: An exception condition occurred in <code>is_leap.pro</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_leap.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong> None.</p></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; year = 2016
IDL&gt; rc = days_per_month(num_days, YEAR = year, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;rc = &#39; + strstr(rc) + &#39;, excpt_cond = &gt;&#39; + $
   excpt_cond + &#39;&lt;&#39;
rc = 0, excpt_cond = &gt;&lt;
IDL&gt; PRINT, &#39;num_days = &#39;, num_days, FORMAT = &#39;(A, 13I5)&#39;
num_days = 366  31  29  31  30  31  30  31  31  30  31  30  31</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;03&#8211;24: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2018&#8211;03&#8211;28: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>discrete_integral</h2>
<ul>
<li><p><strong>Purpose:</strong> This function returns the integral of a mathematical function provided as a discrete set of <code>(x, y)</code> points.</p></li>
<li><p><strong>Algorithm:</strong> This function calculates the &#8216;area under the curve&#8217; defined by the discrete set of <code>(x, y)</code> points, assuming a simple linear interpolation between those points (the so-called &#8220;trapezoidal rule&#8221;). The optional <code>BASELINE</code> keyword allows for adjusting the arbitrary constant inherent with the estimation of a definite integral.</p></li>
<li><p><strong>Syntax:</strong> <code>res = discrete_integral(x, y, BASELINE = baseline, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>x {FLOAT} [I]:</code> The array of independent variable values.</p></li>
<li><p><code>y {FLOAT} [I]:</code> The array of dependent variable values.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>BASELINE = baseline {FLOAT} [I] (Default value: 0.0):</code> The reference dependent variable value from which the &#8216;area under the curve&#8217; will be computed.</p></li>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>FLOAT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns the value of the definite integral of the function defined by the discrete set of <code>(x, y)</code> points, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> was set and if the optional output keyword parameter <code>EXCPT_COND</code> was provided in the call.</p></li>
<li><p>If an exception condition has been detected, this function returns <code>-9999.00</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input positional parameters <code>x</code> and <code>y</code> must be numeric.</p></li>
<li><p>Error 120: Input positional parameters <code>x</code> and <code>y</code> must be arrays containing at least 2 elements.</p></li>
<li><p>Error 130: Input positional parameters <code>x</code> and <code>y</code> must be arrays of the same length.</p></li>
<li><p>Error 140: Optional keyword <code>baseline</code> must be of numeric type.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function implements a strict trapezoidal rule to estimate the integral of the function provided as a discrete set of <code>(x, y)</code> points. If all <code>y</code> values are larger than the <code>baseline</code>, the result may underestimate the integral where the function is concave, and overestimate it where the function is convex, compared to the outcome of a more sophisticated approach, for instance by fitting a smooth curve through the points.</p></li>
<li><p><strong>Note 2:</strong> This function performs all computations in <code>DOUBLE</code> precision, and returns the result as a single precision <code>FLOAT</code> value.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; x = [1.0, 2.0]
IDL&gt; y = [4.0, 6.0]
IDL&gt; res = discrete_integral(x, y, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;res = &#39;, res
res =       5.00000</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p><a href="https://en.wikipedia.org/wiki/Trapezoidal_rule" class="uri">https://en.wikipedia.org/wiki/Trapezoidal_rule</a>, accessed on 24 March 2018.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;03&#8211;24: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2018&#8211;03&#8211;25: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>force_path_sep</h2>
<ul>
<li><p><strong>Purpose:</strong> This function trims the input positional parmeter <code>dir_spec</code> of any white space at the front and at the end of the string, and ensures that it is terminated by the path segment separator character for the current operating system, if it is not already present.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on <code>IDL</code> built-in functions <code>STRTRIM</code> and <code>PATH_SEP</code> to deliver its outcome.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = force_path_sep(dir_spec, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>dir_spec {STRING} [I/O]:</code> An arbitrary directory or path specification, used for both input and output.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided in the call. The input and output positional parameter <code>dir_spec</code> is updated as explained above.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The input positional parameter <code>dir_spec</code> is left untouched.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>dir_spec</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 120: Positional parameter <code>dir_spec</code> must contain at least 1 character.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>last_char.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong> None.</p></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; dir_spec = &#39;   ~/Desktop   &#39;
IDL&gt; rc = force_path_sep(dir_spec)
IDL&gt; PRINT, dir_spec
~/Desktop/

IDL&gt; dir_spec = &#39;~/Desktop/&#39;
IDL&gt; PRINT, force_path_sep(dir_spec)
IDL&gt; PRINT, dir_spec
~/Desktop/

IDL&gt; dir_spec = &#39;Hello&#39;
IDL&gt; print, force_path_sep(dir_spec)
IDL&gt; PRINT, dir_spec
Hello/</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>get_dirs_sizes</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports the size of folders matching the input positional parameter <code>dir_patt</code>, if they exist.</p></li>
<li><p><strong>Algorithm:</strong> This function searches for folder names matching the pattern <code>dir_patt</code>, and, if any are found, spawns a <code>Bash</code> shell script using the <code>Linux</code> command <code>du</code> to report on their sizes.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = get_dirs_sizes(dir_patt, n_dirs, dirs_names, dirs_sizes, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>dir_patt {STRING} [I]:</code> A pattern of folder names.</p></li>
<li><p><code>n_dirs {INT} [O]:</code> The number of matching folders.</p></li>
<li><p><code>dirs_names {STRING array} [O]:</code> The names of the matching folders.</p></li>
<li><p><code>dirs_sizes {STRING array} [O]:</code> A string array containing the sizes of the matching folders.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> was set and if the optional output keyword parameter <code>EXCPT_COND</code> was provided in the call. The output positional parameters <code>n_dirs</code>, <code>dirs_names</code> and <code>dirs_sizes</code> contain the desired information.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameters <code>n_dirs</code>, <code>dirs_names</code> and <code>dirs_sizes</code> may be inexistent, incomplete or incorrect.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>dir_patt</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 120: Positional parameter <code>dir_patt</code> cannot be a null <code>STRING</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>set_white.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function may not work in a MS Windows environment, which lacks the <code>du</code> command.</p></li>
<li><p><strong>Note 2:</strong> The output positional parameter <code>dirs_sizes</code> is of type <code>STRING</code> despite its name and purpose suggesting a number, because it also contains a size unit such as &#8216;M&#8217; for Megabytes, or &#8216;G&#8217; for Gigabytes.</p></li>
<li><p><strong>Note 3:</strong> If no folders are found, the output positional parameter <code>n_dirs</code> is set to <code>0</code> while <code>dirs_names</code> and <code>dirs_sizes</code> are both set to empty <code>STRING</code> arrays.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; rc = get_dirs_sizes(&#39;/Volumes/MISR-HR/P16*&#39;, n_dirs, $
   dirs_names, dirs_sizes, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;rc = &#39; + strstr(rc) + &#39;, excpt_cond = &gt;&#39; + $
   excpt_cond + &#39;&lt;&#39;
rc = 0, excpt_cond = &gt;&lt;
IDL&gt; PRINT, &#39;n_dirs = &#39; + strstr(n_dirs)
n_dirs = 3
IDL&gt; PRINT, dirs_names
/Volumes/MISR-HR/P167/
/Volumes/MISR-HR/P168/
/Volumes/MISR-HR/P169/
IDL&gt; PRINT, dirs_sizes
81G 557G 337G</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;06: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>get_disks_sizes</h2>
<ul>
<li><p><strong>Purpose:</strong> This function retrieves the name, total capacity, used space and available space of each of the disks mounted on the current computer and matching the optional pattern <code>DIR</code>, and passes that information to the calling routine through the output positional parameter <code>disks_sizes</code>. If the optional keyword parameter <code>PRINTIT</code> is set, this information is also printed on the console.</p></li>
<li><p><strong>Algorithm:</strong> This function spawns a Linux <code>df</code> command to the operating system, extracts the desired information from the outcome, and uses it to populate the 2-dimensional output array <code>disks_sizes</code>.</p></li>
<li><p><strong>Syntax:</strong> <code>res = get_disks_sizes(disks_sizes, DIR = dir, $</code><br />
<code>PRINTIT = printit, DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>disks_sizes {STRING array} [O]:</code> A 2-dimensional array containing size information for each disk mounted on the current computer.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DIR = dir {STRING} [I] (Default: &#8221;):</code> The name pattern of the disk(s) to be documented.</p></li>
<li><p><code>PRINTIT = printit {INT} [I] (Default: 0):</code> Flag to activate (1) or skip (0) the printing of the outcome on the console.</p></li>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided in the call. The output positional parameter <code>disks_sizes</code> is set as a 2-dimensional <code>STRING</code> array <code>disks_sizes[n_disks, n_items]</code> whose elements have the following meanings:</p>
<ul>
<li><p><code>N_ELEMENTS(disks_sizes[*, 0])</code> is the number of currently mounted disks meeting the optional selection criterion <code>dir</code>,</p></li>
<li><p><code>disks_sizes[i, 0]</code> contains the name of the mount point for disk <code>i</code>,</p></li>
<li><p><code>disks_sizes[i, 1]</code> contains the total capacity of the disk <code>i</code>,</p></li>
<li><p><code>disks_sizes[i, 2]</code> contains the space already used on disk <code>i</code>, and</p></li>
<li><p><code>disks_sizes[i, 3]</code> contains the space remaining available on disk <code>i</code>.</p></li>
</ul></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameter <code>disks_sizes</code> may be inexistent, incomplete or incorrect.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: The optional keyword parameter <code>dir</code> must be of type <code>STRING</code>.</p></li>
<li><p>Error 120: An exception condition occurred in the spawning of the <code>df</code> command.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>get_host_info.pro</code></p></li>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>set_white.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function relies on Linux&#8217;s <code>df</code> command, so it will only work within the MacOS or Linux environments.</p></li>
<li><p><strong>Note 2:</strong> The 3 numbers reported for each disk found represent the total space, the used space and the remaining available space, respectively.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; dir = &#39;MISR*&#39;
IDL&gt; rc = get_disks_sizes(disks_sizes, DIR = dir, $
   /PRINT, /DEBUG, EXCPT_COND = excpt_cond)
There are 2 disks mounted on MicMac2:
        /Volumes/MISR-HR       1.8Ti       1.8Ti       3.6Gi
     /Volumes/MISR_Data3       3.6Ti       3.3Ti       379Gi</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;03&#8211;29: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;04&#8211;02: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2017&#8211;04&#8211;04: Version 1.1 &#8212; Update the code and documentation to provide the desired information through a positional parameter rather than the return value (now used for error reporting).</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;02&#8211;28: Version 2.01 &#8212; Documentation update.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>get_host_info</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports on the names of the operating system and the computer on which it is running.</p></li>
<li><p><strong>Algorithm:</strong> This function does not require any input; it relies on the <code>IDL</code> <code>!VERSION</code> internal variable and on either the <code>hostname</code> command (on computers running under <code>Linux</code> or <code>Mac</code>), or the environmental variable <code>COMPUTERNAME</code> (on computers running under <code>MS Windows</code>) to define the value of the output positional parameters.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = get_host_info(os_name, comp_name, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>os_name {STRING} [O]:</code> The name of the underlying operating system; under <code>IDL</code> Version 8.7, this output positional parameter is either <code>linux</code>, or <code>darwin</code>, or <code>Win32</code>.</p></li>
<li><p><code>comp_name {STRING} [O]:</code> The name of the computer executing this routine.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided in the call. The output positional parameters <code>os_name</code> and <code>comp_name</code> contain the results generated by this function.</p></li>
<li><p>If an exception condition has been detected, this function returns the warning code <code>98</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameters <code>os_name</code> and <code>comp_name</code> may be inexistent, incomplete or incorrect.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 98: The operating system or the computer is not recognized.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The logic implemented in this function may need to be updated either if one of the operating systems changes its naming convention, or more or different operating systems should be considered, or the mechanism to retrieve the name of the computer changes.</p></li>
<li><p><strong>Note 2:</strong> On computers running under the Microsoft Windows family of operating systems, the user should verify that the environment variable <code>COMPUTERNAME</code> exists prior to using this function.</p></li>
<li><p><strong>Note 3:</strong> Exception condition <code>98</code> does not need to imply a processing interruption, as the input and output folders normally provided by default on the basis of this host information can be overridden explicitly with optional input keyword parameters.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; rc = get_host_info(os_name, comp_name)
IDL&gt; PRINT, &#39;os_name = &#39;, os_name
os_name = darwin
IDL&gt; PRINT, &#39;comp_name = &#39;, comp_name
comp_name = MicMac2</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;07&#8211;03: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2018&#8211;07&#8211;05: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;07&#8211;10: Version 1.1 &#8212; Documentation update.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;02&#8211;26: Version 2.01 &#8212; Minor coding update: Add requirement to call this function with 2 output positional parameters.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>haversine</h2>
<ul>
<li><p><strong>Purpose:</strong> This function computes the haversine distance between the two locations specified by their latitudes and longitudes in decimal degrees.</p></li>
<li><p><strong>Algorithm:</strong> This function implements the classical haversine formula, as described in the references below.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = haversine(lat_1, lon_1, lat_2, lon_2, $</code><br />
<code>distance, DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>lat_1 {DOUBLE} [I]:</code> The latitude of the first location, in decimal degrees.</p></li>
<li><p><code>lon_1 {DOUBLE} [I]:</code> The longitude of the first location, in decimal degrees.</p></li>
<li><p><code>lat_2 {DOUBLE} [I]:</code> The latitude of the second location, in decimal degrees.</p></li>
<li><p><code>lon_2 {DOUBLE} [I]:</code> The longitude of the second location, in decimal degrees.</p></li>
<li><p><code>distance {DOUBLE} [O]:</code> The shortest distance between the two locations, in m, following a great circle on a spherical Earth.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided in the call. The distance between the 2 input locations is provided in output positional parameter.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The distance between the 2 locations may be undefined, incomplete or incorrect.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: The input positional parameter <code>lat_1</code> is not of type <code>FLOAT</code> or <code>DOUBLE</code>.</p></li>
<li><p>Error 112: The input positional parameter <code>lat_1</code> must be in the range <code>[-90.0D, 90.0D]</code>.</p></li>
<li><p>Error 120: The input positional parameter <code>lon_1</code> is not of type <code>FLOAT</code> or <code>DOUBLE</code>.</p></li>
<li><p>Error 122: The input positional parameter <code>lon_1</code> must be in the range <code>[-180.0D, 180.0D]</code>.</p></li>
<li><p>Error 130: The input positional parameter <code>lat_2</code> is not of type <code>FLOAT</code> or <code>DOUBLE</code>.</p></li>
<li><p>Error 132: The input positional parameter <code>lat_2</code> must be in the range <code>[-90.0D, 90.0D]</code>.</p></li>
<li><p>Error 140: The input positional parameter <code>lon_2</code> is not of type <code>FLOAT</code> or <code>DOUBLE</code>.</p></li>
<li><p>Error 142: The input positional parameter <code>lon_2</code> must be in the range <code>[-180.0D, 180.0D]</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_double.pro</code></p></li>
<li><p><code>is_float.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The shortest distance between two locations returned by this function does not take into account any differences in altitude: it only reports on the distance between the specified latitudes and longitudes, on a spherical Earth, at the mean sea level.</p></li>
<li><p><strong>Note 2:</strong> The outcome of this routine is quite sensitive to the number of decimal places and the numerical precision with which the input latitudes and longitudes are provided: this is particularly important for small distances (compare the results of the two examples below).</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; lat_1 = -27.34439555D
IDL&gt; lon_1 = 30.13553714D
IDL&gt; lat_2 = -27.34400537D
IDL&gt; lon_2 = 30.13680177D
IDL&gt; rc = haversine(lat_1, lon_1, lat_2, lon_2, distance)
IDL&gt; PRINT, &#39;distance = &#39;, distance, &#39; m.&#39;, $
   FORMAT = &#39;(3X, A12, D12.8, A)&#39;
distance = 132.22838583 m.

IDL&gt; lat_1 = -27.344D
IDL&gt; lon_1 = 30.135D
IDL&gt; lat_2 = -27.344D
IDL&gt; lon_2 = 30.136D
IDL&gt; rc = haversine(lat_1, lon_1, lat_2, lon_2, distance)
IDL&gt; PRINT, &#39;distance = &#39;, distance, &#39; m.&#39;, $
   FORMAT = &#39;(3X, A12, D12.8, A)&#39;
distance =  98.77053613 m.</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p>https://www.movable-type.co.uk/scripts/latlong.html, visited on 6 April 2019.</p></li>
<li><p>https://en.wikipedia.org/wiki/Earth_radius, visited on 6 April 2019.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2019&#8211;04&#8211;06: Version 1.0 &#8212; Initial release.</p></li>
<li><p>2019&#8211;04&#8211;06: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>is_leap</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>year</code> is a leap year or not.</p></li>
<li><p><strong>Algorithm:</strong> For dates after 4 October 1582, a year that is exactly divisible by four is a leap year, except that years which are exactly divisible by 100 are not leap years, while centurial years that are exactly divisible by 400 are leap years (See the references section below).</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_leap(year, DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>year {INT} [I]:</code> The year to inspect.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>1</code> if the input positional parameter <code>year</code> is a leap year or <code>0</code> it is not a leap year, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns <code>-1</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>year</code> is not of type numeric.</p></li>
<li><p>Error 120: Positional parameter <code>year</code> is anterior to 1582.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function is applicable only to dates of the Gregorian calendar, i.e., years occurring after 4 October 1582.</p></li>
<li><p><strong>Note 2:</strong> Fractional years are rounded off (<code>FLOOR</code>) by ignoring the decimal part: See the second example below.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; res = is_leap(2015, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res, &#39;   &gt;&#39; + excpt_cond + &#39;&lt;&#39;
       0   &gt;&lt;

IDL&gt; res = is_leap(2016.7, DEBUG = 1, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res, &#39;   &gt;&#39; + excpt_cond + &#39;&lt;&#39;
       1   &gt;&lt;

IDL&gt; res = is_leap(512, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res, &#39;   &gt;&#39; + excpt_cond + &#39;&lt;&#39;
      -1   &gt;Error 120 in IS_LEAP: Input input positional
      parameter 512 is anterior to 1582.&lt;</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p>Web site: <code>https://en.wikipedia.org/wiki/Leap_year</code>, accessed on 2017-10-30.</p></li>
<li><p><code>IDL</code> documentation for built-in routine <code>JULDAY</code>.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>iso2jul</h2>
<ul>
<li><p><strong>Purpose:</strong> This function converts an ISO 8601/W3C date, specified as a <code>STRING</code>, into a Julian date provided as a <code>DOUBLE</code> floating point number.</p></li>
<li><p><strong>Algorithm:</strong> This function extracts the elements of the ISO 8601/W3C date specification (<code>yyyy-mm-ddThh:mm:ssZ</code>) and relies on the <code>IDL</code> function <code>JULDAY</code> to generate the corresponding Julian day number.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = iso2jul(isodate, juldate, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>isodate {STRING} [O]:</code> The input date formatted as <code>yyyy-mm-ddThh:mm:ssZ</code>.</p></li>
<li><p><code>juldate {DOUBLE} [I]:</code> The output Julian day number.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided in the call. The output positional parameter <code>juldate</code> contains the Julian day number corresponding to the input positional parameter <code>isodate</code>.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameter <code>juldate</code> may be undefined, inexistent, incomplete or useless.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input positional parameter <code>isodate</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 200: The input positional parameter <code>isodate</code> is incorrectly formatted: it must contain 2 strings separated by <code>T</code>.</p></li>
<li><p>Error 210: The input positional parameter <code>isodate</code> is incorrectly formatted: the date must contain 3 strings separated by <code>-</code>.</p></li>
<li><p>Error 220: The input positional parameter <code>isodate</code> is incorrectly formatted: the time must contain 3 strings separated by <code>:</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>chk_isodate.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> Julian days start at noon local time, so the first 12 hours of a particular civilian day belong to the second half of one Julian day, and the last 12 hours belong to the first half of the next Julian day. See the examples below.</p></li>
<li><p><strong>Note 2:</strong> By default, the <code>IDL</code> function <code>JULDAY</code> returns a <code>LONG</code> integer if the date is specified only using the month, day and year numbers, and as a <code>DOUBLE</code> floating point if the date specification includes the hour, minute or second.</p></li>
<li><p><strong>Note 3:</strong> By default, <code>IDL</code> prints large <code>DOUBLE</code> floating point numbers such as Julian days for contemporary dates with a single decimal digit and rounds the actual numbers in the process. As a result, the Julian day number may appear to be the same before and after noon: to witness the change, use a format statement to force the output of at least two or more decimals. See the examples below.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; isodate = &#39;1953-06-13T11:00:00Z&#39;
IDL&gt; rc = iso2jul(isodate, juldate, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;juldate = &#39;, juldate
juldate =        2434542.0
IDL&gt; PRINT, &#39;juldate = &#39;, juldate, FORMAT = &#39;(A, D12.4)&#39;
juldate = 2434541.9583

IDL&gt; isodate = &#39;1953-06-13T13:00:00Z&#39;
IDL&gt; rc = iso2jul(isodate, juldate, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;juldate = &#39;, juldate
juldate =        2434542.0
IDL&gt; PRINT, &#39;juldate = &#39;, juldate, FORMAT = &#39;(A, D12.4)&#39;
juldate = 2434542.0417</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p><a href="https://www.w3.org/TR/NOTE-datetime" class="uri">https://www.w3.org/TR/NOTE-datetime</a>, accessed on 21 November 2018.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;11&#8211;22: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2018&#8211;11&#8211;30: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>jul2iso</h2>
<ul>
<li><p><strong>Purpose:</strong> This function converts a Julian date, specified as a floating point number in <code>DOUBLE</code> precision, into an ISO 8601/W3C date, specified as a <code>STRING</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> program <code>CALDAT</code> to extract the date elements from the input Julian date, and reformats those into the ISO 8601/W3C date specification (<code>yyyy-mm-ddThh:mm:ssZ</code>).</p></li>
<li><p><strong>Syntax:</strong> <code>rc = jul2iso(juldate, isodate, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>juldate {DOUBLE} [I]:</code> The input Julian day number.</p></li>
<li><p><code>isodate {STRING} [O]:</code> The output date, formatted as per the ISO 8601/W3C specifications.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided in the call. The output positional parameter <code>isodate</code> contains the date corresponding to the input Julian day number.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameter <code>isodate</code> may be undefined, inexistent, incomplete or useless.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input positional parameter juldate is not of type <code>DOUBLE</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_double.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> Julian days start at noon local time, so the first 12 hours of a particular civilian day belong to the second half of one Julian day, and the last 12 hours belong to the first half of the next Julian day. See the examples below.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; juldate = 2458444.0D
IDL&gt; rc = jul2iso(juldate, isodate, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;isodate = &#39; + isodate
isodate = 2018-11-21T12:00:00Z

IDL&gt; juldate = 2458443.9D
IDL&gt; rc = jul2iso(juldate, isodate, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;isodate = &#39; + isodate
isodate = 2018-11-21T09:36:00Z</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p><a href="https://www.w3.org/TR/NOTE-datetime" class="uri">https://www.w3.org/TR/NOTE-datetime</a>, accessed on 21 November 2018.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;11&#8211;20: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2018&#8211;11&#8211;30: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;02&#8211;24: Version 2.01 &#8212; Documentation update.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>make_bytemap</h2>
<ul>
<li><p><strong>Purpose:</strong> This function generates and saves, in the folder <code>save_spec</code>, a PNG-formatted graphic representation of the input positional parameter <code>byte_array</code>, where the <code>BYTE</code> values contained in the array <code>good_vals</code> are coded in the colors contained in the array <code>good_vals_cols</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function creates a graphical representation of the 2-D array <code>byte_array</code> where the values contained in <code>good_vals</code> are plotted in the corresponding colors given in <code>good_vals_cols</code>. Values in the data array that are not listed in <code>good_vals</code> are assigned the default color <code>0</code>, which is black. The list of recognized colors is defined by the World Wide Web Consortium (W3C) and are listed in the IDL documentation under the entry <code>!COLOR</code>.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = make_bytemap(byte_array, good_vals, good_vals_cols, $</code><br />
<code>save_spec, DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>byte_array {BYTE array} [I]:</code> A 2-D array of values of type <code>BYTE</code>.</p></li>
<li><p><code>good_vals {BYTE array} [I]:</code> A 1-D array of values of type <code>BYTE</code>.</p></li>
<li><p><code>good_vals_cols {STRING array} [I]:</code> A 1-D array of standard color names, as defined by W3C or IDL.</p></li>
<li><p><code>save_spec {STRING} [I]:</code> The file specification to be used to save the graphic file.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided in the call. The output graphic file is saved in the location specified by the input positional parameter <code>save_spec</code>, and the implied directory path is created if it does not exist.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output graphic file is not generated and is not saved.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input positional parameter <code>byte_array</code> is not of type <code>BYTE</code>.</p></li>
<li><p>Error 120: Input positional parameter <code>byte_array</code> is not a 2D array.</p></li>
<li><p>Error 130: Input positional parameter <code>good_vals</code> is not of type <code>BYTE</code> or <code>INT</code>.</p></li>
<li><p>Error 140: Input positional parameter <code>good_vals</code> contains none or more than 256 values.</p></li>
<li><p>Error 150: Input positional parameter <code>good_vals_cols</code> must be of type <code>STRING</code>.</p></li>
<li><p>Error 160: Input positional parameter <code>good_vals_cols</code> contains none or more than 256 values.</p></li>
<li><p>Error 170: Input positional parameters <code>good_vals</code> and <code>good_vals_cols</code> must have the same dimensions.</p></li>
<li><p>Error 180: At least one of the specified color names is unrecognized.</p></li>
<li><p>Error 190: The input positional parameter <code>save_spec</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 400: The output folder <code>save_fpath</code> is unwritable.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>is_writable_dir.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> Values contained in the input data array <code>byte_array</code> that are not listed in the input array <code>good_vals</code> have no explicitly assigned color code in the map, which defaults to a color code <code>0</code>, and hence to the first color listed in <code>good_vals_cols</code>.</p></li>
<li><p><strong>Note 2:</strong> Different values of the input array <code>good_vals</code> can be assigned the same color in <code>good_vals_cols</code>, as long as these two arrays have the same dimension to ensure the correspondence between their matching elements.</p></li>
<li><p><strong>Note 3:</strong> A given value of the input array <code>good_vals</code> can be assigned multiple colors in <code>good_vals_cols</code>, as long as these two arrays have the same dimension to ensure the correspondence between their matching elements. In that case, assignments associated with a higher index in those files supersede those made previously.</p></li>
<li><p><strong>Note 4:</strong> The input array <code>good_vals</code> may contain values that are not present in the input data array <code>byte_array</code>, as long as the input array <code>good_vals_cols</code> also contains a nominal color assignment, which will be ignored.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; byte_array = BYTARR(200, 50)
IDL&gt; FOR i = 0, 146 DO byte_array[i, *] = BYTE(i)
IDL&gt; good_vals = BINDGEN(147)
IDL&gt; good_vals_cols = TAG_NAMES(!COLOR)
IDL&gt; rc = make_bytemap(byte_array, good_vals, $
   good_vals_cols, &#39;~/Desktop/test.png&#39;, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;rc = &#39; + strstr(rc) + &#39; and excpt_cond = &gt;&#39; + $
   excpt_cond + &#39;&lt;&#39;
rc = 0 and excpt_cond = &gt;&lt;</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p>See the color conventions recommended by the World Wide Web Consortium (W3C) [<a href="https://www.w3.org/TR/2018/REC-css-color-3-20180619/" class="uri">https://www.w3.org/TR/2018/REC-css-color-3-20180619/</a>], or the IDL documentation under the entry <code>!COLOR</code>.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;08&#8211;04: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2018&#8211;08&#8211;10: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;09&#8211;25: Version 1.1 &#8212; Move the code line to document the nature and properties of the input positional parameter <code>byte_array</code> before the initial testing block to ensure the function works when the <code>DEBUG</code> option is not used.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>n_min_max</h2>
<ul>
<li><p><strong>Purpose:</strong> This function computes the number of local minima and maxima in the input numerical array <code>series</code>, optionally ignoring values that are strictly smaller than <code>ignore_below</code> or that are strictly larger than <code>ignore_above</code>, and provides their values and positions in the series.</p></li>
<li><p><strong>Algorithm:</strong> This function identifies the number of times sequences of continuously increasing values are followed by sequences of continuously decreasing values, and conversely, in the input numerical array <code>series</code>. Once these numbers are known, appropriately sized arrays are generated and populated with the desired information.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = n_min_max(series, n_seqs, n_mins, mins, i_mins, $</code><br />
<code>n_maxs, maxs, i_maxs, MISSING = missing, $</code><br />
<code>IGNORE_BELOW = ignore_below, IGNORE_ABOVE = ignore_above, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>series {FLOAT array} [I]:</code> A 1-dimensional input numerical array of arbitrary size.</p></li>
<li><p><code>n_seqs {LONG} [O]:</code> The number of uninterrupted sequences (runs) of consecutive valid (i.e., containing no missing) values in the input numerical array <code>series</code>.</p></li>
<li><p><code>n_mins {LONG} [O]:</code> The number of local minima found in the input numerical array <code>series</code>.</p></li>
<li><p><code>mins {FLOAT array} [O]:</code> The values of the local minima found in the input numerical array <code>series</code>.</p></li>
<li><p><code>i_mins {LONG} [O]:</code> The positions of these local minima within the input numerical array <code>series</code>.</p></li>
<li><p><code>n_maxs {LONG} [O]:</code> The number of local maxima found in the input numerical array <code>series</code>.</p></li>
<li><p><code>maxs {FLOAT array} [O]:</code> The values of the local maxima found in the input numerical array <code>series</code>.</p></li>
<li><p><code>i_maxs {LONG} [O]:</code> The positions of these local maxima within the input numerical array <code>series</code>.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>MISSING = missing {INT} [I] (Default value: 0):</code> Flag to indicate whether the input numerical array <code>series</code> contains missing values (<code>1</code>) or not (<code>0</code>). If it does, then the input keyword parameters <code>IGNORE_BELOW</code> and <code>IGNORE_ABOVE</code> are both required.</p></li>
<li><p><code>IGNORE_BELOW = ignore_below {FLOAT } [I]:</code> The numerical threshold below which all values of the input numerical array <code>series</code> must be ignored.</p></li>
<li><p><code>IGNORE_ABOVE = ignore_above {FLOAT } [I]:</code> The numerical threshold above which all values of the input numerical array <code>series</code> must be ignored.</p></li>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided in the call. The output positional parameters contain the results generated by this function.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameters may be incomplete or incorrect.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: The input positional parameters <code>series</code> is not a numerical array.</p></li>
<li><p>Error 120: The input keyword parameter <code>missing</code> is set and the input keyword parameters <code>ignore_below</code> and <code>ignore_above</code> are identical.</p></li>
<li><p>Error 130: The input positional parameter <code>series</code> does not contain at least 3 valid values.</p></li>
<li><p>Error 200: The input positional parameter <code>series</code> does not contain at least 1 sequence of at least 1 valid value.</p></li>
<li><p>Error 210: No minimum or no maximum was found in the input positional parameter <code>series</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_array.pro</code></p></li>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> No local minimum or maximum is assigned to an uninterrupted sequence (or run) where all (valid) values are equal, though the sequence itself is properly identified.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; series = [1.1, 2.1, 1.2, 2.4, 5.6, 4.3]
IDL&gt; rc = n_min_max(series, n_seqs, $
   n_mins, mins, i_mins, n_maxs, maxs, i_maxs)
IDL&gt; PRINT, &#39;n_seqs = &#39;, n_seqs
n_seqs =            1
IDL&gt; PRINT, &#39;n_mins = &#39;, n_mins
n_mins =            3
IDL&gt; PRINT, &#39;mins = &#39;, mins
mins =       1.10000      1.20000      4.30000
IDL&gt; PRINT, &#39;i_mins = &#39;, i_mins
i_mins =            0           2           5
IDL&gt; PRINT, &#39;n_maxs = &#39;, n_maxs
n_maxs =            2
IDL&gt; PRINT, &#39;maxs = &#39;, maxs
maxs =       2.10000      5.60000
IDL&gt; PRINT, &#39;i_maxs = &#39;, i_maxs
i_maxs =            1           4</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2007&#8211;07&#8211;14: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2019&#8211;12&#8211;01: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;12&#8211;06: Version 2.1.0 &#8212; Adopt revised coding and documentation standards, and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>oom</h2>
<ul>
<li><p><strong>Purpose:</strong> This routine returns an integer value representing the order of magnitude of the absolute value of the input positional parameter <code>arg</code> in the optional logarithmic base <code>base</code> (10 by default).</p></li>
<li><p><strong>Algorithm:</strong> If the input positional parameter <code>arg</code> is not null and if the optional keyword parameter <code>base</code> is strictly positive, the function returns <code>FLOOR(alogb(ABS(arg), base))</code>. In all other cases, the function returns <code>NaN</code> and raises an exception condition.</p></li>
<li><p><strong>Syntax:</strong> <code>res = oom(arg, BASE = base, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg</code> is an arbitrary but non-null numeric expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>BASE = base {Numeric} [I] (Default value: 10.0):</code> An arbitrary but strictly positive numeric expression.</p></li>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns the order of magnitude of the absolute value of the input positional parameter <code>arg</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns <code>NaN</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>arg</code> is not of type numeric.</p></li>
<li><p>Error 120: Input keyword parameter <code>base</code> is specified but not numeric.</p></li>
<li><p>Error 130: Input keyword parameter <code>base</code> is not strictly positive.</p></li>
<li><p>Error 200: Scalar input keyword parameter <code>arg</code> is indistinguishable from <code>0.0</code>.</p></li>
<li><p>Error 210: An exception condition occurred in function <code>alogb.pro</code>.</p></li>
<li><p>Error 220: At least one of the elements of the array input positional parameter <code>arg</code> is indistinguishable from <code>0.0</code>.</p></li>
<li><p>Error 230: An exception condition occurred in function <code>alogb.pro</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>alogb.pro</code></p></li>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The input positional parameter <code>arg</code> can be a scalar or an array.</p></li>
<li><p><strong>Note 2:</strong> If the input positional parameter <code>arg</code> is of type <code>COMPLEX</code>, the function returns the order of magnitude of the modulus of the complex number, which can be larger than either of the components of that number: See the examples below.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = 99.9
IDL&gt; PRINT, oom(a)
           1

IDL&gt; b = 100.0
IDL&gt; PRINT, oom(b)
           2

IDL&gt; c = -1234.56
IDL&gt; PRINT, oom(c)
           3

IDL&gt; d = 1.0E-50
IDL&gt; PRINT, oom(d)
  2147483647
% Program caused arithmetic error: Floating divide by 0
% Program caused arithmetic error: Floating illegal operand
IDL&gt; PRINT, oom(d, /DEBUG, EXCPT_COND = excpt_cond)
          NaN
IDL&gt; PRINT, &#39;excpt_cond = &#39; + excpt_cond
excpt_cond = Error 200 in OOM: Scalar input positional parameter arg is indistinguishable from 0.0.

IDL&gt; e = [234.0, -32.1]
IDL&gt; PRINT, oom(e)
       2       1</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.8 &#8212; Initial release.</p></li>
<li><p>2017&#8211;07&#8211;11: Version 0.9 &#8212; Moved former input positional parameter <code>base</code> into an optional keyword parameter.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Update the function to handle negative input positional parameters <code>arg</code>, update the documentation, adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
<li><p>2019&#8211;10&#8211;05: Version 2.1.1 &#8212; Simplify and update the code to handle array arguments, update the documentation.</p></li>
</ul></li>
</ul>
<h2>percentile</h2>
<ul>
<li><p><strong>Purpose:</strong> This function estimates the sample value <code>thresh</code> of the specified percentile <code>per</code> in the input <code>array</code> and returns some basic statistical information on that <code>array</code>, which may contain missing values and does not need to be sorted prior to the call.</p></li>
<li><p><strong>Algorithm:</strong> This function determines the sample value corresponding to the desired percentile <code>per</code> by either selecting a particular item of <code>array</code>, if it corresponds exactly, or interpolating between two <code>array</code> sample values otherwise. If missing values may be present in <code>array</code> (i.e., input keyword parameter <code>AMISS</code> is set), then</p>
<ul>
<li><p>the range of valid values must be specified by setting the input keyword parameters <code>ignore_below</code> and <code>ignore_above</code> (missing values are deemed to lie outside of that range), and</p></li>
<li><p>the output keyword parameters <code>amin</code> and <code>amax</code> report the minimum and maximum valid values within that range, as opposed to within the original <code>array</code>.</p></li>
</ul></li>
<li><p><strong>Syntax:</strong> <code>rc = percentile(per, array, amin, amax, thresh, $</code><br />
<code>AMISS = amiss, IGNORE_BELOW = ignore_below, $</code><br />
<code>IGNORE_ABOVE = ignore_above, COUNT = count, $</code><br />
<code>DOUBLE = double, DEBUG = debug, EXCPT_COND = excpt_cond</code>)</p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>per {FLOAT} [I]:</code> The desired percentile, a decimal number within the range <code>[0.0, 1.0]</code>.</p></li>
<li><p><code>array {FLOAT array} [I]:</code> The statistical sample from which the percentile needs to be estimated.</p></li>
<li><p><code>amin {FLOAT} [O]:</code> The minimum value of array. If the optional input keyword parameters <code>AMISS</code> is set, this minimum value is for the valid values contained within the allowed range <code>[ignore_below, ignore_above]</code>.</p></li>
<li><p><code>amax {FLOAT} [O]:</code> The maximum value of array. If the optional input keyword parameters <code>AMISS</code> is set, this maximum value is for the valid values contained within the allowed range <code>[ignore_below, ignore_above]</code>.</p></li>
<li><p><code>thresh {FLOAT} [O]:</code> The threshold value in the given array, within the allowed range <code>[ignore_below, ignore_above]</code>, if specified, such that <code>per</code> percents of the sorted array elements are smaller than or equal to <code>thresh</code>.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>AMISS = amiss {INT} [I]:</code> Flag indicating whether the array contains (<code>1</code>) or does not contain (<code>0</code>) missing values. If missing values are present in <code>array</code>, they are assumed to be strictly smaller than <code>ignore_below</code> or strictly larger than <code>ignore_above</code>.</p></li>
<li><p><code>IGNORE_BELOW = ignore_below {STRING} [I]:</code> Minimum valid value within the input positional parameter <code>array</code>: If the <code>AMISS</code> keyword has been set, this keyword is mandatory and all array values strictly lower than this value are ignored for the purpose of computing statistics and <code>thresh</code>.</p></li>
<li><p><code>IGNORE_ABOVE = ignore_above {STRING} [I]:</code> Maximum valid value within the input positional parameter <code>array</code>: If the <code>AMISS</code> keyword has been set, this keyword is mandatory and all array values strictly higher than this value are ignored for the purpose of computing statistics and <code>thresh</code>.</p></li>
<li><p><code>COUNT = count {LONG} [O]:</code> If the keyword parameter <code>AMISS</code> is not set, <code>count</code> is the number of elements of <code>array</code>. If the keyword parameter <code>AMISS</code> is set, <code>count</code> reports on the number of non-missing elements in <code>array</code> that were considered in the estimation of the percentile <code>thresh</code> (i.e., the number of <code>array</code> elements within the range <code>[ignore_below, ignore_above]</code>.</p></li>
<li><p><code>DOUBLE = double {INT} [I]:</code> Flag requesting explicitly (<code>1</code>) that computations be carried out in double precision or not (<code>0</code>).</p></li>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> was set and if the optional output keyword parameter <code>EXCPT_COND</code> was provided in the call. The output positional parameters <code>amin</code>, <code>amax</code> and <code>thresh</code> provide the minimum and maximum values of the input positional parameter <code>array</code>, as well as the desired percentile, respectively.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero value, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameters <code>thresh</code>, <code>amin</code> and <code>amax</code> are set to <code>!VALUES.F_INFINITY</code>.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: The requested percentile is not a number within the range <code>[0.0, 1.0]</code>.</p></li>
<li><p>Error 120: Input positional parameter <code>array</code> is not a numeric array.</p></li>
<li><p>Error 130: Input keyword parameter <code>AMISS</code> is set while keywords <code>IGNORE_BELOW</code> and <code>IGNORE_ABOVE</code> are both null.</p></li>
<li><p>Error 140: Input positional parameter <code>array</code> contains fewer than 3 valid elements.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The input positional parameter <code>array</code> can be multi-dimensional, but the resulting <code>thresh</code> applies to all elements of <code>array</code>.</p></li>
<li><p><strong>Note 2:</strong> If the input keyword parameter <code>AMISS</code> is set, the keyword parameters <code>ignore_below</code> and <code>ignore_above</code> are required. At least one of them must be set explicitly to a non-zero value, otherwise all values are considered missing.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = [1, 7, 3, -99, 4, 5, -99, 9, 6, 2, 8]
IDL&gt; PRINT, N_ELEMENTS(a), MIN(a), MAX(a)
          11     -99       9
IDL&gt; rc = percentile(0.5, a, amin, amax, thresh, /AMISS, $
   IGNORE_BELOW = &#39;0&#39;, IGNORE_ABOVE = &#39;100&#39;, COUNT = count, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, rc, &#39;   &gt;&#39; + excpt_cond + &#39;&lt;&#39;
       0   &gt;&lt;
IDL&gt; PRINT, thresh, count, amin, amax
       5           9       1       9</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p>Web page<br />
<code>http://www.itl.nist.gov/div898/handbook/prc/section2/prc252.htm</code>,<br />
visited on 30 Oct 2017.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2008&#8211;01&#8211;01: Version 0.5 &#8212; Initial release under the name <code>prctl</code>.</p></li>
<li><p>2008&#8211;10&#8211;14: Version 0.6 &#8212; Corrections to the documentation.</p></li>
<li><p>2015&#8211;04&#8211;05: Version 0.7 &#8212; Add reporting the min and max values within the allowable range.</p></li>
<li><p>2017&#8211;01&#8211;05: Version 0.8 &#8212; Update in-line documentation and add the optional <code>COUNT</code> keyword parameter.</p></li>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Changed function name to percentile, converted some of the input positional parameters into keyword parameters, updated the in-line documentation, implemented the keywords <code>ignore_below</code> and <code>ignore_above</code> as strings to avoid the incorrect interpretation of a null value.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Update and simplify the function, adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>remove_path_sep</h2>
<ul>
<li><p><strong>Purpose:</strong> This function trims the input positional parmeter <code>dir_spec</code> of any white space at the front and at the end of the string, and ensures that it is not terminated by the path segment separator character for the current operating system, if it is present.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on <code>IDL</code> built-in functions <code>STRTRIM</code> and <code>PATH_SEP</code> to deliver its outcome.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = remove_path_sep(dir_spec, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>dir_spec {STRING} [I/O]:</code> An arbitrary directory or path specification, used for both input and output.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided in the call. The input and output positional parameter <code>dir_spec</code> is updated as explained above.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The input positional parameter <code>dir_spec</code> is left untouched.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>dir_spec</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 120: Positional parameter <code>dir_spec</code> must contain at least 1 character.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>last_char.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong> None.</p></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; dir_spec = &#39;    ~/Desktop/   &#39;
IDL&gt; debug = 1
IDL&gt; rc = remove_path_sep(dir_spec, DEBUG = debug, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;dir_spec = &gt;&#39; + dir_spec + &#39;&lt;&#39;
dir_spec = &gt;~/Desktop&lt;</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2020&#8211;01&#8211;09: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2020&#8211;01&#8211;10: Version 2.1.0 &#8212; Adopt revised coding and documentation standards, and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>round_dec</h2>
<ul>
<li><p><strong>Purpose:</strong> This function returns a <code>STRING</code> representation of the input positional parameter <code>arg</code>, rounded to <code>n_dec</code> decimals.</p></li>
<li><p><strong>Algorithm:</strong> If the input positional parameter <code>arg</code></p>
<ul>
<li><p>is of type <code>FLOAT</code>, <code>DOUBLE</code>, <code>COMPLEX</code> or <code>DCOMPLEX</code>, the function returns a <code>STRING</code> representation of <code>arg</code> with the specified number of decimal places;</p></li>
<li><p>is of one of the integer types, the function returns <code>arg</code> unchanged.</p></li>
<li><p>is not numeric, the function returns <code>NaN</code>.</p></li>
</ul></li>
<li><p><strong>Syntax:</strong> <code>res = round_dec(arg, n_dec, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond</code>)</p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg {Number} [I]:</code> An arbitrary numeric expression, typically of one of the types <code>FLOAT</code>, <code>DOUBLE</code>, <code>COMPLEX</code> or <code>DCOMPLEX</code>. Integer values are tolerated (the function returns the input unmodified).</p></li>
<li><p><code>n_dec {INT} [I]:</code> The desired number of decimal digits in the result.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>STRING</code>, or <code>Number</code> or <code>NaN</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected and the type of the input positional parameter <code>arg</code> is <code>INTEGER</code>, <code>COMPLEX</code>, or one of the compound data types, this function returns the value <code>arg</code> itself and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If no exception condition has been detected and the input positional parameter <code>arg</code> is either of type <code>FLOAT</code> or <code>DOUBLE</code>, this function returns a numeric approximation of the input positional parameter <code>arg</code>, rounded to <code>n_dec</code> significant decimals, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns <code>NaN</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input positional parameter <code>arg</code> must be numeric.</p></li>
<li><p>Error 120: Input positional parameter <code>n_dec</code> must be numeric.</p></li>
<li><p>Error 130: Input positional parameter <code>n_dec</code> must be a scalar.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>is_scalar.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
<li><p><code>type_of.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The returned (<code>STRING</code>) value can be converted back to a numeric expression using the <code>IDL</code> built-in functions <code>FLOAT</code> and <code>DOUBLE</code>, for instance.</p></li>
<li><p><strong>Note 2:</strong> The input positional parameter <code>arg</code> can be a scalar or an array.</p></li>
<li><p><strong>Note 3:</strong> If the required number of decimals <code>n_dec</code> exceeds the number of decimals provided in the input positional parameter <code>arg</code>, the result is padded with zeros.</p></li>
<li><p><strong>Note 4:</strong> If the required number of decimals <code>n_dec</code> exceeds the inherent precision of the input number, this function returns a result equal to the input <code>arg</code>. See the examples below.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; arg = 12.345678
IDL&gt; n_dec = 2
IDL&gt; res = round_dec(arg, n_dec, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;arg = &#39;, arg, &#39;n_dec = &#39;, n_dec, &#39;res = &#39;, res, $
   FORMAT = &#39;(A6, 3X, F18.7, 3X, A8, I3, 3X, A6, A)&#39;
arg =            12.3456783   n_dec =   2   res = 12.35

IDL&gt; arg = 12.987654
IDL&gt; n_dec = 1
IDL&gt; res = round_dec(arg, n_dec, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;arg = &#39;, arg, &#39;n_dec = &#39;, n_dec, &#39;res = &#39;, res, $
   FORMAT = &#39;(A6, 3X, F18.7, 3X, A8, I3, 3X, A6, A)&#39;
arg =            12.9876537   n_dec =   1   res = 13.0

IDL&gt; arg = [1.23456, 2.34567]
IDL&gt; n_dec = 1
IDL&gt; res = round_dec(arg, n_dec, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, arg
      1.23456      2.34567
IDL&gt; PRINT, res
      1.20000      2.30000

IDL&gt; arg = [DCOMPLEX(12.345678, -98.432101), $
   DCOMPLEX(-34.567890, 87.543215)]
IDL&gt; n_dec = 2
IDL&gt; res = round_dec(arg, n_dec)
IDL&gt; PRINT, &#39;res = &#39; + res
      res = (12.35, -98.43) res = (-34.57, 87.54)</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;04&#8211;17: Version 2.01 &#8212; Update the code to always round the decimal part of the input argument to 64-bit integers.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Improve the algorithm to handle arrays and <code>COMPLEX</code> arguments, update the documentation, adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
<li><p>2019&#8211;10&#8211;05: Version 2.1.1 &#8212; Update the code to correctly handle a null argument.</p></li>
</ul></li>
</ul>
<h2>set_cap</h2>
<ul>
<li><p><strong>Purpose:</strong> This function capitalizes the first word, and optionally each word or all characters, of the input positional parameter <code>arg</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function scans the input positional parameter <code>arg</code> to identify the first valid letter and capitalizes it. This operation can also be optionally performed on each word (continuous sequence of letters) or on all characters.</p></li>
<li><p><strong>Syntax:</strong> <code>res = set_cap, arg, $</code><br />
<code>ALLCHARS = allchars, ALLWORDS = allwords, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg {STRING} [I]:</code> The string that needs to be capitalized.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>ALLCHARS = allchars {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) capitalizing all characters of the input positional parameter <code>arg</code>.</p></li>
<li><p><code>ALLWORDS = allwords {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) capitalizing all words of the input positional parameter <code>arg</code>.</p></li>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>STRING</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns a version of the input positional parameter <code>arg</code>, capitalized as follows:</p>
<ul>
<li><p>If neither of the optional keyword parameters <code>ALLCHARS</code> and <code>ALLWORDS</code> are set (default), the first letter of the first word of <code>arg</code> is set in upper case.</p></li>
<li><p>If the optional keyword parameter <code>ALLCHARS</code> is set, all letters of <code>arg</code> are set in upper case.</p></li>
<li><p>If the optional keyword parameter <code>ALLWORDS</code> is set, the first letter of each word of <code>arg</code> is set in upper case.</p></li>
<li><p>If both optional keyword parameters <code>ALLCHARS</code> and <code>ALLWORDS</code> are set, the former takes precedence and all letters of <code>arg</code> are set in upper case.</p></li>
<li><p>The input positional parameter <code>arg</code> is left unmodified.</p></li>
</ul>
<p>In all of these cases, the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided in the call.</p></li>
<li><p>If an exception condition has been detected, this function returns a null string, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input positional parameter <code>arg</code> is not of type <code>STRING</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_array.pro</code></p></li>
<li><p><code>is_letter.pro</code></p></li>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The input positional parameter <code>arg</code> may be a <code>STRING</code> array, in which case all elements of that array are processed as indicated above.</p></li>
<li><p><strong>Note 2:</strong> Characters other than letters are ignored and copied over verbatim to the returned value.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; PRINT, set_cap(&#39;south africa&#39;)
South africa

IDL&gt; PRINT, set_cap(&#39;hello&#39;, /ALLCHARS)
HELLO

IDL&gt; PRINT, set_cap(&#39; 12  hello&#39;, /ALLCHARS)
 12  HELLO

IDL&gt; PRINT, set_cap([&#39;south africa&#39;, &#39;united states&#39;], /ALLWORDS)
South Africa United States</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;12&#8211;02: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2018&#8211;12&#8211;12: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>set_value_range</h2>
<ul>
<li><p><strong>Purpose:</strong> This function returns an &#8216;optimal&#8217; value range to be used in plotting routines, based on the actual minimum and maximum values of the variable to be displayed. It can substitute the default range used by <code>IDL</code> in the <code>PLOT</code> function, if the latter is not satisfactory.</p></li>
<li><p><strong>Algorithm:</strong> This function selects the minimum and maximum values of a range that contains the values provided as input, decreased and increased by about 1/10th of the range between those values, and appropriately rounded.</p></li>
<li><p><strong>Syntax:</strong> <code>res = set_value_range(min_val, max_val, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>min_val {FLOAT} [I]:</code> The actual minimum valid value in a dataset, i.e., not considering special codes for missing values.</p></li>
<li><p><code>max_val {FLOAT} [I]:</code> The actual maximum valid value in a dataset, i.e., not considering special codes for missing values.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>FLOAT array</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns the optimal range to plot values within <code>[min_val, max_val]</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns the dummy range <code>res = [-99.9, -99.9]</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>min_val</code> or <code>max_val</code> is not of numeric type.</p></li>
<li><p>Error 120: The actual range <code>max_val - min_val</code> is null.</p></li>
<li><p>Error 130: An exception condition occurred in routine <code>oom.pro</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>oom.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong> None.</p></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; res = set_value_range(0.12, 0.62, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
      0.00000     0.700000
IDL&gt; PRINT, &#39;excpt_cond = &gt;&#39; + excpt_cond + &#39;&lt;&#39;
excpt_cond = &gt;&lt;

IDL&gt; res = set_value_range(-2.5, 12.7)
IDL&gt; PRINT, res
     -10.0000      20.0000

IDL&gt; res = set_value_range(15.0, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
     -99.9000     -99.9000
IDL&gt; PRINT, &#39;excpt_cond = &#39; + excpt_cond
excpt_cond = Error 100 in set_value_range: Routine must be
   called with 2 positional parameters: min_val, max_val.</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>set_year_range</h2>
<ul>
<li><p><strong>Purpose:</strong> This function returns a time interval, defined by two Julian dates, containing complete common years, that includes the time interval specified by <code>jul_ini_date</code> and <code>jul_fin_date</code>.</p></li>
<li><p><strong>Algorithm:</strong> This routines returns an array of two Julian dates ranging from the 31st of December of the year before the specified initial date to the 1st of January of the year following the specified final date.</p></li>
<li><p><strong>Syntax:</strong> <code>res = set_year_range(jul_ini_date, jul_fin_date, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>jul_ini_date {DOUBLE} [I]:</code> The initial Julian date.</p></li>
<li><p><code>jul_fin_date {DOUBLE} [I]:</code> The final Julian date.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>DOUBLE array</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns the date interval that includes the time interval specified by <code>jul_ini_date</code> and <code>jul_fin_date</code> and comprises full common years. The output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns the dummy range <code>res = [-99.9D, -99.9D]</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input positional parameters <code>jul_ini_date</code> and <code>jul_fin_date</code> must both be of numeric type.</p></li>
<li><p>Error 120: Input positional parameters <code>jul_ini_date</code> and <code>jul_fin_date</code> must both be scalars.</p></li>
<li><p>Error 130: Input positional parameters <code>jul_ini_date</code> and <code>jul_fin_date</code> must both be posterior to 4 October 1582.</p></li>
<li><p>Error 140: Julian date <code>jul_ini_date</code> must precede Julian date <code>jul_fin_date</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>is_scalar.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function is useful to set the time axis on time series plots so that the graphic display includes full common years.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; jul1 = JULDAY(2, 24, 2000)
IDL&gt; jul2 = JULDAY(6, 13, 2015)
IDL&gt; PRINT, jul1, jul2
     2451599     2457187
IDL&gt; res = set_year_range(jul1, jul2, /DEBUG, $
   EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
     2451544     2457389
IDL&gt; PRINT, &#39;excpt_cond = &gt;&#39; + excpt_cond + &#39;&lt;&#39;
excpt_cond = &gt;&lt;
IDL&gt; CALDAT, 2451544, mo1, dy1, yr1
IDL&gt; CALDAT, 2457389, mo2, dy2, yr2
IDL&gt; PRINT, mo1, dy1, yr1
          12          31        1999
IDL&gt; PRINT, mo2, dy2, yr2
           1           1        2016

IDL&gt; res = set_year_range(jul2, jul1, /DEBUG, $
   EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
     -99.9000     -99.9000
IDL&gt; PRINT, &#39;excpt_cond = &#39; + excpt_cond
excpt_cond = Error 140 in SET_YEAR_RANGE:
   Julian date &#39;jul_ini_date&#39; = 2457187.0 must precede
   Julian date &#39;jul_fin_date&#39; = 2451599.0.</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>sha256</h2>
<ul>
<li><p><strong>Purpose:</strong> This function returns the SHA-2 (256 bits) hash signature of the input file <code>file_spec</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function spawns a Bash shell script using the Linux command <code>shasum -a 256</code> and returns the signature to the calling routine.</p></li>
<li><p><strong>Syntax:</strong> <code>res = sha256(file_spec, DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>file_spec {STRING} [I]:</code> The input file specification, with an optional path but a mandatory name, of the file to characterize.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>STRING</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns the SHA-2 (256 bits) hash signature of the input file, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns <code>&#8217;-1&#8217;</code>, and the keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: File <code>file_spec</code> is not found, not a regular file or not readable.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function may or may not work in a MS Windows environment, depending on whether a <code>shasum -a 256</code> command is available from the operating system.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; PRINT, sha256(&#39;./IDLWorkspace/Utilities/dummy.txt&#39;, $
   /DEBUG, EXCPT_COND = excpt_cond)
4ea226bae70b6dc623a62314486f7846ed5e458a0718082964925e735f2823ea</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p>Web page: <code>https://en.wikipedia.org/wiki/SHA-2</code>.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;04&#8211;24: Version 1.1 &#8212; Update debugging messages.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;05&#8211;17: Version 2.01 &#8212; Code simplification (<code>FILE_TEST</code>).</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>strcat</h2>
<ul>
<li><p><strong>Purpose:</strong> This function returns a scalar <code>STRING</code> variable that combines all elements of the input positional parameter <code>str_array</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function concatenates the elements of the input positional parameter <code>str_array</code>, in their original order, into a single scalar <code>STRING</code> variable, using the input positional parameter <code>sep_char</code> character as separator between successive elements.</p></li>
<li><p><strong>Syntax:</strong> <code>res = strcat(str_array, separator, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>str_array {STRING} [I]:</code> An arbitrary string array.</p></li>
<li><p><code>separator {STRING} [I] (Default value: None):</code> Character string used to separate the array elements in the output string.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>STRING</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns a string scalar and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns a null string and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input positional parameter <code>str_array</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 120: Input positional parameter <code>sep_char</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 130: Input positional parameter <code>sep_char</code> is not a scalar.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_array.pro</code></p></li>
<li><p><code>is_scalar.pro</code></p></li>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The input positional parameter <code>str_array</code> can be multi-dimensional. In the case of a 2D array, the elements are concatenated line by line.</p></li>
<li><p><strong>Note 2:</strong> If the input positional parameter <code>str_array</code> is empty or a scalar <code>STRING</code>, this function returns that argument unmodified.</p></li>
<li><p><strong>Note 3:</strong> The input positional parameter <code>sep_char</code> can be a null string or contain multiple characters.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = [&#39;multi&#39;, &#39;spectral&#39;]
IDL&gt; res = strcat(a, &#39;&#39;)
IDL&gt; PRINT, &#39;&gt;&#39; + res + &#39;&lt;&#39;
&gt;multispectral&lt;

IDL&gt; str_array = [[&#39;This&#39;, &#39;is&#39;, &#39;a&#39;], [&#39;2D&#39;, &#39;string&#39;, &#39;array&#39;]]
IDL&gt; res = strcat(str_array, &#39; &#39;, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
This is a 2D string array

IDL&gt; str_array = [&#39;P168&#39;, &#39;O068050&#39;, &#39;B110&#39;]
IDL&gt; separator = &#39;_&#39;
IDL&gt; res = strcat(str_array, separator, $
   DEBUG = 1, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;res = &gt;&#39; + res + &#39;&lt;&#39;
res = &gt;P168_O068050_B110&lt;</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;18: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2018&#8211;12&#8211;04: Version 1.6 &#8212; Convert the input keyword parameter <code>sep_char</code> into the input positional parameter <code>separator</code> to allow concatenation with empty separators.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>strrepeat</h2>
<ul>
<li><p><strong>Purpose:</strong> This function generates and returns an output string containing <code>n_rep</code> times the input positional parameter <code>str</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function replicates the input positional parameter <code>str</code> <code>n_rep</code> times and returns the result to the calling routine.</p></li>
<li><p><strong>Syntax:</strong> <code>res = strrepeat(str, n_rep, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>str {STRING} [I]:</code> A string expression.</p></li>
<li><p><code>n_rep {INT} [I]:</code> The total number of times the input string <code>str</code> needs to be replicated in the output string.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>STRING</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns a string scalar, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> was set and if the optional output keyword parameter <code>EXCPT_COND</code> was provided in the call.</p></li>
<li><p>If an exception condition has been detected, this function returns a null string and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>str</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 120: Positional parameter <code>n_rep</code> is not of type <code>INTEGER</code>.</p></li>
<li><p>Error 130: Positional parameter <code>n_rep</code> is negative.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_integer.pro</code></p></li>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> If the input positional parameter <code>n_rep</code> is <code>0</code>, this function returns a null string, irrespective of the content of the input positional parameter <code>str</code>.</p></li>
<li><p><strong>Note 2:</strong> If the input positional parameter <code>n_rep</code> is <code>1</code>, this function returns the value of <code>str</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; res = strrepeat(&#39;--123--&#39;, 4, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
--123----123----123----123--

IDL&gt; title = &#39;This is a title&#39;
IDL&gt; PRINT, title, STRING(10B), strrepeat(&#39;-&#39;, STRLEN(title), $
   /DEBUG, EXCPT_COND = excpt_cond)
This is a title
---------------</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;08&#8211;01: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2018&#8211;12&#8211;04: Version 1.6 &#8212; Update the function documentation.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>strstr</h2>
<ul>
<li><p><strong>Purpose:</strong> This function converts the value of the alphanumeric positional parameter <code>arg</code> into a string without any white space in the front or at the back.</p></li>
<li><p><strong>Algorithm:</strong> This routine converts the input positional parameter <code>arg</code> to a <code>STRING</code> and strips any white space in the front or back.</p></li>
<li><p><strong>Syntax:</strong> <code>res = strstr(arg, DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg {alphanumeric} [I]:</code> The alphanumeric input variable to process.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>STRING</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns the string representation of the input positional parameter <code>arg</code> to the calling routine, and the keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns a null string and the keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>arg</code> is not of type alphanumeric.</p></li>
<li><p>Error 200: Unexpected condition, check the type of input positional parameter <code>arg</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_alphanum.pro</code></p></li>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The input positional parameter <code>arg</code> can be an array, in which case each array element is converted into a string without any blank space in the front or at the back.</p></li>
<li><p><strong>Note 2:</strong> Note that if an exception condition is encountered, this function calls itself recursively to output the corresponding message.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; pi = 3.14159
IDL&gt; PRINT, pi
      3.14159
IDL&gt; res = strstr(pi)
IDL&gt; PRINT, res
3.14159

IDL&gt; a = &#39;   Hello   &#39;
IDL&gt; PRINT, &#39;&gt;&#39; + a + &#39;&lt;&#39;
&gt;   Hello   &lt;
IDL&gt; res = strstr(a)
IDL&gt; PRINT, &#39;&gt;&#39; + res + &#39;&lt;&#39;
&gt;Hello&lt;

IDL&gt; a = CREATE_STRUCT(&#39;A&#39;, 1, &#39;B&#39;, &#39;xxx&#39;)
IDL&gt; res = strstr(a, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;&gt;&#39; + res + &#39;&lt;&#39;
&gt;&lt;
IDL&gt; PRINT, excpt_cond
Error 110 in routine STRSTR: Input positional
   parameter arg is not an alphanumeric expression.

IDL&gt; b = [&#39;   Hello   &#39;, &#39;   World   &#39;]
IDL&gt; res = strstr(b)
IDL&gt; PRINT, &#39;&gt;&#39; + res[0] + &#39;&lt;&#39; + &#39; &#39; + &#39;&gt;&#39; + res[1] + &#39;&lt;&#39;
&gt;Hello&lt; &gt;World&lt;</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
<h2>today</h2>
<ul>
<li><p><strong>Purpose:</strong> This function returns today&#8217;s date and time as a string in one of the following formats, specified by the optional input keyword parameter <code>FMT</code>: default (keyword <code>FMT</code> not set or unrecognized), <code>iso</code>, <code>jul</code>, <code>julian</code>, <code>nice</code>, <code>usa</code>, <code>ymd</code> or <code>dmy</code>.</p></li>
<li><p><strong>Algorithm:</strong> This routine implements some of the recommendations by World Wide Web Consortium (W3C) regarding simplified formats to represent dates and times, as provided originally by the ISO 8601 standard. It relies on the <code>IDL</code> function <code>SYSTIME</code> to generate the information (in <code>IDL</code>&#8217;s format) and reformats the result as described below.</p></li>
<li><p><strong>Syntax:</strong> <code>res = today(FMT = fmt)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>FMT = fmt {STRING} [I]:</code> Set this optional keyword to <code>iso</code>, <code>jul</code>, <code>julian</code>, <code>nice</code>, <code>usa</code>, <code>ymd</code> or <code>dmy</code> to generate the return value in a format different from the default. If the value of this keyword is not set or unrecognized, the result will be formatted according to the default format.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>STRING</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns today&#8217;s date to the calling routine in one of the following formats:</p>
<ul>
<li><p>If the keyword <code>FMT</code> is NOT set (default), or is unrecognized, the current date and time are provided as a string formatted like <code>YYYY-MM-DD_hh:mm:ss</code>.</p></li>
<li><p>If the keyword <code>FMT</code> is set to <code>iso</code>, the current date and time are provided as a string formatted like <code>YYYY-MM-DDThh:mm:ssZ</code>.</p></li>
<li><p>If the keyword <code>FMT</code> is set to <code>jul</code>, the current date is provided as the current Julian day number, i.e., a <code>STRING</code> representation of a <code>LONG</code> integer.</p></li>
<li><p>If the keyword <code>FMT</code> is set to <code>julian</code>, the current date and time are provided as the current Julian day number and time, i.e., a <code>STRING</code> representation of a <code>DOUBLE</code> floating point number.</p></li>
<li><p>If the keyword <code>FMT</code> is set to <code>nice</code>, the current date and time are provided as a string formatted like <code>YYYY-MM-DD at hh:mm:ss</code>.</p></li>
<li><p>If the keyword <code>FMT</code> is set to <code>usa</code>, the current date is provided as a string formatted like <code>Mo DD, YYYY</code>, where <code>Mon</code> is a 3-character string abreviation of the month name.</p></li>
<li><p>If the keyword <code>FMT</code> is set to <code>ymd</code>, the current date is provided as a string formatted like <code>YYYY-MM-DD</code>.</p></li>
<li><p>If the keyword <code>FMT</code> is set to <code>dmy</code>, the current date is provided as a string formatted like <code>DD Month YYYY</code>, where <code>Month</code> is the month name, spelled out in full.</p></li>
</ul></li>
<li><p>This routine does not provide diagnostic information on exception conditions.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The format option <code>FMT</code> can be specified in either upper or lower (or even mixed) case.</p></li>
<li><p><strong>Note 2:</strong> This routine does not (currently) attempt to report on the time zone.</p></li>
<li><p><strong>Note 3:</strong> The output formats <code>nice</code> and <code>usa</code> may be less desirable for use in filenames because of the presence of blank characters.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; res = today()
IDL&gt; PRINT, res
2017-03-09_20-56-45

IDL&gt; res = today(FMT = &#39;nice&#39;)
IDL&gt; PRINT, res
2017-03-09 at 20:57:14

IDL&gt; res = today(FMT = &#39;ymd&#39;)
IDL&gt; PRINT, res
2017-03-09</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p>Web page: <code>https://www.w3.org/TR/NOTE-datetime</code>.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2019&#8211;01&#8211;04: Version 1.2 &#8212; Add the optional output formats <code>jul</code> and <code>julday</code>.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
<li><p>2020&#8211;01&#8211;27: Version 2.1.1 &#8212; Add the optional keyword value <code>dmy</code> and update the documentation.</p></li>
</ul></li>
</ul>
<h2>uniq2</h2>
<ul>
<li><p><strong>Purpose:</strong> This function sorts and sifts two one-dimensional arrays of identical type and dimensions, retaining only the couples of unique values while maintaining the correspondance between elements of the same rank in each input array.</p></li>
<li><p><strong>Algorithm:</strong> This function combines the two input positional parameter arrays into a single <code>STRING</code> array, sorts and sifts it to eliminate duplicates, and then splits it back into arrays of the original type but containing only unique pairs of corresponding values.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = uniq2(in_array_1, in_array_2, out_array_1, out_array_2, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>in_array_1 [I]:</code> An arbitrary array.</p></li>
<li><p><code>in_array_2 [I]:</code> An arbitrary array of the same type and size as <code>in_array_1</code>.</p></li>
<li><p><code>out_array_1 [O]:</code> An array of the same type and size as <code>in_array_1</code> containing the elements of <code>in_array_1</code> which are uniquely associated with elements of <code>in_array_2</code>.</p></li>
<li><p><code>out_array_2 [O]:</code> An array of the same type and size as <code>in_array_1</code> containing the elements of <code>in_array_2</code> which are uniquely associated with elements of <code>in_array_1</code>.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> was set and if the optional output keyword parameter <code>EXCPT_COND</code> was provided in the call. The positional parameters <code>out_array_1</code> and <code>out_array_2</code> contain the unique combinations of values of the input positional parameters.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameters may be undefined, inexistent, incomplete or useless.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Both input positional parameters <code>in_array_1</code> and <code>in_array_2</code> must be arrays.</p></li>
<li><p>Error 120: The input positional parameters <code>in_array_1</code> and <code>in_array_2</code> must be of the same size.</p></li>
<li><p>Error 130: The input positional parameters <code>in_array_1</code> and <code>in_array_2</code> must be of the same type.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_array.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
<li><p><code>type_of.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The positional parameters <code>in_array_1</code> and <code>in_array_2</code> can be of any alphanumeric type, but must be defined.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; in_array_1 = [1.1, 1.1, 2.2, 2.2, 3.3, 3.3, $
   4.4, 4.4, 4.4, 2.2, 5.5]
IDL&gt; in_array_2 = [0.0, 0.0, 1.1, 2.2, 3.3, 3.3, $
   3.3, 4.4, 3.3, 2.2, 6.1]
IDL&gt; rc = uniq2(in_array_1, in_array_2, out_array_1, out_array_2, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;rc = &#39; + strstr(rc) + &#39;, excpt_cond = &gt;&#39; + $
   excpt_cond + &#39;&lt;&#39;
rc = 0, excpt_cond = &gt;&lt;
IDL&gt; PRINT, out_array_1
1.10000  2.20000  2.20000  3.30000  4.40000  4.40000  5.50000
IDL&gt; PRINT, out_array_2
0.00000  1.10000  2.20000  3.30000  3.30000  4.40000  6.10000</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;04&#8211;29: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2018&#8211;05&#8211;14: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;02&#8211;28: Version 2.01 &#8212; Documentation update.</p></li>
<li><p>2019&#8211;08&#8211;20: Version 2.1.0 &#8212; Adopt revised coding and documentation standards (in particular regarding the assignment of numeric return codes), and switch to 3-parts version identifiers.</p></li>
</ul></li>
</ul>
</body>
</html>
