<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
   <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>Documentation for the IDL routines in project Utilities</title>
   </head>
<body>
<h1>Documentation for the IDL routines in project Utilities</h1>
<h2>alogb</h2>
<ul>
<li><p><strong>Purpose:</strong> This function returns the logarithm of the input positional parameter <code>arg</code> to an arbitrary <code>base</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function computes the logarithm of a strictly positive numeric (but not complex) scalar or array <code>arg</code> to an arbitrary but strictly positive numeric (but not complex and different from 1.0) scalar or array <code>base</code> as<br />
<span class="math inline">log&#8198;(<em>a</em><em>r</em><em>g</em>,&#8198;<em>b</em><em>a</em><em>s</em><em>e</em>)&#8196;=&#8196;log&#8198;(<em>a</em><em>r</em><em>g</em>,&#8198;10)/log&#8198;(<em>b</em><em>a</em><em>s</em><em>e</em>,&#8198;10)</span>,<br />
where both <code>arg</code> and <code>base</code>.</p></li>
<li><p><strong>Syntax:</strong> <code>res = alogb(arg, base, DOUBLE = double, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg {Number} [I]:</code> An arbitrary but strictly positive numeric (not complex) scalar or array.</p></li>
<li><p><code>base {Number} [I]:</code> An arbitrary but strictly positive numeric (not complex) scalar or array, different from 1.0.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DOUBLE = double {INT} [I] (Default value: 0):</code> Flag to request computation in <code>DOUBLE</code> (<code>1</code>) or single (<code>0</code>) precision.</p></li>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>FLOAT</code> scalar or array, <code>DOUBLE</code> scalar or array, or <code>NaN</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns the following result, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided:</p>
<ul>
<li><p>If <code>arg</code> is an array and <code>base</code> is a scalar, then the logarithm of each element of <code>arg</code> is computed in base <code>base</code>.</p></li>
<li><p>If <code>arg</code> is a scalar and <code>base</code> is an array, then the logarithm of <code>arg</code> is computed in each element of base <code>base</code>.</p></li>
<li><p>If <code>arg</code> and <code>base</code> are both arrays, the logarithm of each element <code>i</code> of <code>arg</code> is computed in the corresponding element <code>i</code> of <code>base</code>. And in that case, if these arrays are of different sizes, the computation stops as soon as all elements of the shorter array have been processed.</p></li>
</ul></li>
<li><p>If an exception condition has been detected, this function returns <code>NaN</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>arg</code> is not of numeric type.</p></li>
<li><p>Error 120: Positional parameter <code>base</code> is not of numeric type.</p></li>
<li><p>Error 130: Positional parameters <code>arg</code> and/or <code>base</code> cannot be of type <code>COMPLEX</code> or <code>DCOMPLEX</code>.</p></li>
<li><p>Error 140: Positional parameter <code>arg</code> is a scalar not strictly positive.</p></li>
<li><p>Error 150: Positional parameter <code>arg</code> is an array with at least one element not strictly positive.</p></li>
<li><p>Error 160: Positional parameter <code>base</code> is a scalar not strictly positive.</p></li>
<li><p>Error 170: Positional parameter <code>base</code> is an array with at least one element not strictly positive.</p></li>
<li><p>Error 180: Positional parameter <code>base</code> must be different from 1.0.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_array.pro</code></p></li>
<li><p><code>is_complex.pro</code></p></li>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> Input positional parameters <code>arg</code> and <code>base</code> can be provided in any positive numeric type, but the returned result will always be of type <code>FLOAT</code> or <code>DOUBLE</code>.</p></li>
<li><p><strong>Note 2:</strong> The function returns <code>NaN</code> if either input positional parameter is not a strictly positive number.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = 100.0
IDL&gt; res = alogb(a, 10)
IDL&gt; PRINT, res
      2.00000

IDL&gt; res = alogb(a, 5, DOUBLE = 1, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
       2.8613531
IDL&gt; PRINT, 5^res
       100.00000

IDL&gt; res = alogb(a, EXP(1.0), DOUBLE = 0)
IDL&gt; PRINT, res
       4.6051704
IDL&gt; PRINT, EXP(4.60517)
      100.000

IDL&gt; res = alogb(-1.0, 10, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
          NaN
IDL&gt; PRINT, excpt_cond
Error 140 in ALOGB: Input positional parameter arg
   is a scalar not strictly positive.

IDL&gt; res = alogb([10.0, 100.0, 1000.0], 10, DOUBLE = 0)
IDL&gt; PRINT, &#39;res = &#39;, res
res =       1.00000      2.00000      3.00000</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p><a href="https://en.wikipedia.org/wiki/Logarithm" class="uri">https://en.wikipedia.org/wiki/Logarithm</a>, accessed 3 Jan 2018.</p></li>
<li><p><a href="https://en.wikipedia.org/wiki/Complex_logarithm" class="uri">https://en.wikipedia.org/wiki/Complex_logarithm</a>, accessed 3 Jan 2018.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;02&#8211;24: Version 2.01 &#8212; Documentation update.</p></li>
</ul></li>
</ul>
<p>Input positional parameter</p>
<h2>chk_isodate</h2>
<ul>
<li><p><strong>Purpose:</strong> This function checks the validity of the input positional parameter <code>isodate</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function verifies that the input positional parameter <code>isodate</code> is a <code>STRING</code> formatted as <code>yyyy-mm-ddThh:nn:ssZ</code> where</p>
<ul>
<li><p><code>yyyy</code> is a valid 4-digit year number,</p></li>
<li><p><code>mm</code> is a valid 2-digit month number,</p></li>
<li><p><code>dd</code> is a valid 2-digit day number,</p></li>
<li><p><code>hh</code> is a valid 2-digit hour number,</p></li>
<li><p><code>nn</code> is a valid 2-digit minute number, and</p></li>
<li><p><code>ss</code> is a valid 2-digit second number.</p></li>
</ul></li>
<li><p><strong>Syntax:</strong> <code>rc = chk_isodate(isodate, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>isodate {STRING} [I]:</code> A string containing a date and time specification formatted as <code>yyyy-mm-ddThh:nn:ssZ</code>.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> was set and if the optional output keyword parameter <code>EXCPT_COND</code> was provided in the call.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input positional parameter <code>isodate</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 200: The input positional parameter <code>isodate</code> is incorrectly formatted: it must contain 2 strings separated by <code>T</code>.</p></li>
<li><p>Error 210: The input positional parameter <code>isodate</code> is incorrectly formatted: the date must contain 3 strings separated by <code>-</code>.</p></li>
<li><p>Error 220: The input positional parameter <code>isodate</code> is incorrectly formatted: the time must contain 3 strings separated by <code>:</code>.</p></li>
<li><p>Error 230: The input positional parameter <code>isodate</code> is invalid: the year must be within the range [1582, 2100].</p></li>
<li><p>Error 240: The input positional parameter <code>isodate</code> is invalid: the month must be within the range [1, 12].</p></li>
<li><p>Error 250: An exception condition occurred in <code>days_per_month.pro</code>.</p></li>
<li><p>Error 260: The input positional parameter <code>isodate</code> is invalid: the day must be within the range [1, number of days in the month].</p></li>
<li><p>Error 270: The input positional parameter <code>isodate</code> is invalid: the hour must be within the range [0, 23].</p></li>
<li><p>Error 280: The input positional parameter <code>isodate</code> is invalid: the minute must be within the range [0, 59].</p></li>
<li><p>Error 290: The input positional parameter <code>isodate</code> is invalid: the second must be within the range [0, 59].</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>days_per_month.pro</code></p></li>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>last_char.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> Since the purpose of this function is to check the validity of the input positional parameter <code>isodate</code>, all tests are performed irrespective of the setting of the input keyword parameter <code>DEBUG</code>. The keywords <code>DEBUG</code> and <code>EXCPT_COND</code> are included for consistency, and to allow reporting of the exception condition if one is encountered.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; isodate = &#39;2018-06-13T12:00:00Z&#39;
IDL&gt; rc = chk_isodate(isodate, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;rc = &#39; + strstr(rc) + &#39;, excpt_cond = &gt;&#39; + $
   excpt_cond + &#39;&lt;&#39;
rc = 0, excpt_cond = &gt;&lt;

IDL&gt; isodate = &#39;2018-06-13T32:00:00Z&#39;
IDL&gt; rc = chk_isodate(isodate, DEBUG = 0, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;rc = &#39; + strstr(rc) + &#39;, excpt_cond = &gt;&#39; + $
   excpt_cond + &#39;&lt;&#39;
rc = 340, excpt_cond = &gt;Error 270 in CHK_ISODATE: Input positional
   parameter isodate is invalid: the hour must be within the range
   [0, 23].&lt;

IDL&gt; isodate = &#39;2018-06-13T32:00:00Z&#39;
IDL&gt; rc = chk_isodate(isodate)
IDL&gt; PRINT, &#39;rc = &#39; + strstr(rc)
rc = 270</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p><a href="https://www.w3.org/TR/NOTE-datetime" class="uri">https://www.w3.org/TR/NOTE-datetime</a>, accessed on 21 November 2018.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;03&#8211;25: Version 0.9 &#8212; Initial release under the name <code>chk_date_iso.pro</code>.</p></li>
<li><p>2018&#8211;03&#8211;28: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;04&#8211;03: Version 1.1 &#8212; Updated error diagnostics.</p></li>
<li><p>2018&#8211;04&#8211;23: Version 1.2 &#8212; Bug fix (missing parenthesis on line 287).</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2018&#8211;11&#8211;23: Version 1.6 &#8212; Change the name of the routine from <code>chk_date_iso.pro</code> to <code>chk_isodate.pro</code>, remove the output positional parameter <code>julian_iso</code> and the code to compute its value, as this functionality is now available with function<br />
<code>iso2jul.pro</code>, perform all diagnostic tests irrespective of the value of the optional input keyword parameter <code>DEBUG</code>, and update the documentation.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>chk_ymddate</h2>
<ul>
<li><p><strong>Purpose:</strong> This function analyzes the <code>STRING</code> input positional parameter <code>date</code>, formatted as <code>YYYY-MM-DD</code>, and provides the <code>year</code>, <code>month</code> and <code>day</code> values as numeric output positional parameters.</p></li>
<li><p><strong>Algorithm:</strong> This function splits the input positional parameter <code>date</code> on character <code>-</code> and sets the output positional parameters <code>year</code>, <code>month</code> and <code>day</code> to their numerical values. If the input keyword parameter <code>DEBUG</code> is set, this function also checks the validity of <code>date</code> and of its 3 components: the year number <code>YYYY</code> must be larger than 1582 and smaller than 2100, the month number <code>MM</code> must be larger than 0 and smaller than 13, while the day number <code>DD</code> must be larger than 0 and smaller than the number of days in that month, accounting for the possibility of a leap year.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = chk_ymddate(date, year, month, day, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>date {STRING} [I]:</code> A string indicating a date.</p></li>
<li><p><code>year {INT} [O]:</code> The numeric year of date <code>date</code>.</p></li>
<li><p><code>month {INT} [O]:</code> The numeric month of date <code>date</code>.</p></li>
<li><p><code>day {INT} [O]:</code> The numeric day of date <code>date</code>.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> was set and if the optional output keyword parameter <code>EXCPT_COND</code> was provided in the call. The output positional parameters <code>year</code>, <code>month</code> and <code>day</code> provide the desired numeric information.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameters corresponding to invalid values are set to <code>0</code>.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>date</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 120: Positional parameter <code>date</code> is not of length 10.</p></li>
<li><p>Error 130: Positional parameter <code>date</code> does not contain a dash character.</p></li>
<li><p>Error 140: Positional parameter <code>date</code> does not contain 2 dash characters.</p></li>
<li><p>Error 150: Positional parameter <code>date</code> does not contain 3 elements separated by 2 dashes.</p></li>
<li><p>Error 160: Positional parameter <code>date</code> specifies an invalid year.</p></li>
<li><p>Error 170: Positional parameter <code>date</code> specifies an invalid month.</p></li>
<li><p>Error 180: Positional parameter <code>date</code> specifies an invalid day.</p></li>
<li><p>Error 200: An exception condition occurred in <code>days_per_month.pro</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>days_per_month.pro</code></p></li>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> Since the purpose of this function is to check the validity of the input positional parameter <code>date</code>, all tests are performed irrespective of the setting of the input keyword parameter <code>DEBUG</code>. The keywords <code>DEBUG</code> and <code>EXCPT_COND</code> are included for consistency, and to allow reporting of the exception condition if one is encountered.</p></li>
<li><p><strong>Note 2:</strong> The month and day elements of the input positional parameter <code>date</code> must be 0-filled to make up a 10-character long string; hence a date like 5 Feb 2011 must be provided as <code>2011-02-05</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; rc = chk_ymddate(&#39;2010-01-01&#39;, year, month, day, $
   DEBUG = 1, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, rc, &#39;   &gt;&#39; + excpt_cond + &#39;&lt;&#39;
       0   &gt;&lt;
IDL&gt; PRINT, year, month, day
    2010       1       1

IDL&gt; rc = chk_ymddate(&#39;2200-01-01&#39;, year, month, day, $
   DEBUG = 1, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, rc, &#39;   &gt;&#39; + excpt_cond + &#39;&lt;&#39;
     160   &gt;Error 160 in CHK_DATE_YMD: Year 2200 is invalid
      (must be 4 digits long and lie within [1582, 2100]).&lt;

IDL&gt; rc = chk_ymddate(&#39;1999-02-29&#39;, year, month, day, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, rc, &#39;   &gt;&#39; + excpt_cond + &#39;&lt;&#39;
     180   &gt;Error 180 in CHK_DATE_YMD: Day 29 is invalid
     (must be 2 digits long and lie within
     [1, #days in the month]).&lt;
IDL&gt; PRINT, year, month, day
    1999       2       0</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;09&#8211;07: Version 0.9 &#8212; Initial release under the name <code>chk_date_ymd.pro</code>.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;03&#8211;28: Version 1.2 &#8212; Update the code to use the new function<br />
<code>days_per_month.pro</code>.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2018&#8211;12&#8211;13: Version 1.6 &#8212; Rename this function to <code>chk_ymddate.pro</code>.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>cor_arrays</h2>
<ul>
<li><p><strong>Purpose:</strong> This function computes various statistics to describe the possible relations between two arrays containing the same number of data points. The results are stored in the pre-existing output structure <code>stats</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on <code>IDL</code> built-in routines to compute the desired statistics.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = cor_arrays(array_1, array_2, stats, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>array_1 {FLOAT array} [I]:</code> The first array to consider.</p></li>
<li><p><code>array_2 {FLOAT array} [I]:</code> The second array to consider.</p></li>
<li><p><code>stats {STRUCTURE} [I/O]:</code> A pre-existing structure to hold the statistical results, organized as follows:</p>
<pre><code>stats = CREATE_STRUCT(NAME = &#39;Bivariate&#39;, $
   &#39;experiment&#39;, 0, $
   &#39;array_1_id&#39;, &#39;&#39;, $
   &#39;array_2_id&#39;, &#39;&#39;, $
   &#39;N_points&#39;, 0L, $
   &#39;RMSD&#39;, 0.0, $
   &#39;Pearson_cc&#39;, 0.0, $
   &#39;Spearman_cc&#39;, 0.0, $
   &#39;Spearman_sig&#39;, 0.0, $
   &#39;Spearman_D&#39;, 0.0, $
   &#39;Spearman_PROBD&#39;, 0.0, $
   &#39;Spearman_ZD&#39;, 0.0, $
   &#39;Linear_fit_1&#39;, &#39;&#39;, $
   &#39;Linfit_a_1&#39;, 0.0, $
   &#39;Linfit_b_1&#39;, 0.0, $
   &#39;Linfit_CHISQR_1&#39;, 0.0, $
   &#39;Linfit_PROB_1&#39;, 0.0, $
   &#39;Linear_fit_2&#39;, &#39;&#39;, $
   &#39;Linfit_a_2&#39;, 0.0, $
   &#39;Linfit_b_2&#39;, 0.0, $
   &#39;Linfit_CHISQR_2&#39;, 0.0, $
   &#39;Linfit_PROB_2&#39;, 0.0)</code></pre></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> was set and if the optional output keyword parameter <code>EXCPT_COND</code> was provided in the call. The desired statistics are contained in the output structure <code>stats</code>.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output structure may be empty, incomplete or useless.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>array_1</code> or <code>array_2</code> is not of type numeric.</p></li>
<li><p>Error 120: Positional parameter <code>array_1</code> or <code>array_2</code> is not an array.</p></li>
<li><p>Error 130: Positional parameter <code>array_1</code> and <code>array_2</code> are of different sizes.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The structure elements <code>experiment</code>, <code>array_1_id</code> and <code>array_2_id</code> are intended to contain a numeric identifier for the experiment and descriptors of these two positional parameters. These should be set prior to calling this function.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; stats = CREATE_STRUCT(NAME = &#39;Bivariate&#39;, $
IDL&gt;    &#39;experiment&#39;, 0, $
IDL&gt;    &#39;array_1_id&#39;, &#39;&#39;, $
IDL&gt;    &#39;array_2_id&#39;, &#39;&#39;, $
IDL&gt;    &#39;N_points&#39;, 0L, $
IDL&gt;    &#39;RMSD&#39;, 0.0, $
IDL&gt;    &#39;Pearson_cc&#39;, 0.0, $
IDL&gt;    &#39;Spearman_cc&#39;, 0.0, $
IDL&gt;    &#39;Spearman_sig&#39;, 0.0, $
IDL&gt;    &#39;Spearman_D&#39;, 0.0, $
IDL&gt;    &#39;Spearman_PROBD&#39;, 0.0, $
IDL&gt;    &#39;Spearman_ZD&#39;, 0.0, $
IDL&gt;    &#39;Linear_fit_1&#39;, &#39;&#39;, $
IDL&gt;    &#39;Linfit_a_1&#39;, 0.0, $
IDL&gt;    &#39;Linfit_b_1&#39;, 0.0, $
IDL&gt;    &#39;Linfit_CHISQR_1&#39;, 0.0, $
IDL&gt;    &#39;Linfit_PROB_1&#39;, 0.0, $
IDL&gt;    &#39;Linear_fit_2&#39;, &#39;&#39;, $
IDL&gt;    &#39;Linfit_a_2&#39;, 0.0, $
IDL&gt;    &#39;Linfit_b_2&#39;, 0.0, $
IDL&gt;    &#39;Linfit_CHISQR_2&#39;, 0.0, $
IDL&gt;    &#39;Linfit_PROB_2&#39;, 0.0)
IDL&gt; x1 = [65,63,67,64,68,62,70,66,68,67,69,71]
IDL&gt; y1 = [68,66,68,65,69,66,68,65,71,67,68,70]
IDL&gt; stats.experiment = 1
IDL&gt; stats.array_1_id = &#39;x1&#39;
IDL&gt; stats.array_2_id = &#39;y1&#39;
IDL&gt; rc = cor_arrays(x1, y1, stats, /DEBUG, $
IDL&gt;    EXCPT_COND = excpt_cond)
IDL&gt; fmt = &#39;(A20, A)&#39;
IDL&gt; PRINT, &#39;N_points = &#39;, strstr(stats.N_points), FORMAT = fmt
      N_points = 12
IDL&gt; PRINT, &#39;RMSD = &#39;, strstr(stats.RMSD), FORMAT = fmt
      RMSD = 2.10159
...
IDL&gt; PRINT, &#39;Linear_fit_2 = &#39;, strstr(stats.Linear_fit_2), $
IDL&gt;    FORMAT = fmt
     Linear_fit_2 = array_1 = a + b x array_2
IDL&gt; PRINT, &#39;Linfit_a_2 = &#39;, strstr(stats.Linfit_a_2), $
IDL&gt;    FORMAT = fmt
     Linfit_a_2 = -3.37687
...</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;02&#8211;28: Version 0.8 &#8212; Initial release under the name <code>cor_fields</code>.</p></li>
<li><p>2017&#8211;07&#8211;20: Version 0.9 &#8212; Renamed function to <code>cor_arrays</code>, removed any reference to <span class="smallcaps">MISR</span> or <span class="smallcaps">MISR-HR</span> (generic utility routine), updated documentation.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>count_code_lines</h2>
<ul>
<li><p><strong>Purpose:</strong> This function returns the approximate number of code lines (as a <code>LONG</code> integer) contained in the text file specified by the input positional parameter <code>file_spec</code>, i.e., the number of lines that are neither blank (empty) nor beginning with a string expression contained in <code>comm_char</code> denoting the start of a comment.</p></li>
<li><p><strong>Algorithm:</strong> This function inspects each and every line of <code>file_spec</code> and counts those that are neither empty nor starting with one of the string(s) provided in <code>comm_char</code>. Blank space (space, TAB) at the start of the line is ignored for this purpose. The <code>STRING</code> variable <code>comm_char</code> can be either a constant or an array, in which case all elements of that array are used in succession to check all possible options. Each element of <code>comm_char</code> can include multiple characters (e.g., to deal with <code>C</code> or <code>PL-1</code> language conventions such as /* comment */).</p></li>
<li><p><strong>Syntax:</strong> <code>res = count_code_lines(file_spec, comm_char, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>file_spec {STRING} [I]:</code> The file specification (optional path and name) of the text file to inspect.</p></li>
<li><p><code>comm_char {STRING or STRING array} [I]:</code> One (scalar) or more (if array) string expression(s) containing the usual characters to indicate comments in computer languages.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>LONG</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns the approximate number of code lines in <code>file_spec</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns <code>-1L</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>file_spec</code> is not of type STRING.</p></li>
<li><p>Error 120: Positional parameter <code>file_spec</code> is not a scalar.</p></li>
<li><p>Error 130: Positional parameter <code>file_spec</code> is not found or unreadable.</p></li>
<li><p>Error 140: Positional parameter <code>comm_char</code> is not of type <code>STRING</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_array.pro</code></p></li>
<li><p><code>is_readable.pro</code></p></li>
<li><p><code>is_scalar.pro</code></p></li>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The <code>IDL</code> built-in command <code>FILE_LINES</code> counts and returns the total number of lines in a text file. By contrast, the function <code>count_code_lines</code> reports on the number of active or effective code lines, i.e., without counting comments and empty lines.</p></li>
<li><p><strong>Note 2:</strong> The <code>STRING</code> variable <code>comm_char</code> can be either a scalar or an array, in which case all elements of that array are used in succession to check all possible options. Each element of <code>comm_char</code> can include multiple characters (e.g., to deal with <code>C</code> or <code>PL-1</code> language conventions such as <code>/* comment */</code>). And if <code>comm_char</code> is set to a scalar null string, this function returns the total number of lines in the file, as reported by <code>FILE_LINES</code>.</p></li>
<li><p><strong>Note 3:</strong> This routine may not yield the correct number of code lines if comments span multiple lines, each terminated by a <code>&lt;CR&gt;</code> and/or <code>&lt;LF&gt;</code>, without repeating the commenting character sequence on each line. However, a comment written on a single long line, which may appear on multiple lines on screen due to soft wrapping, would be treated correctly.</p></li>
<li><p><strong>Note 4:</strong> This function is also usable in other contexts that use a character string at the start of a line to indicate comments, such as in LaTeX, for instance.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; file_spec = &#39;./Codes/IDL/Utilities/is_leap/is_leap.pro&#39;
IDL&gt; PRINT, FILE_LINES(file_spec)
                   206
IDL&gt; PRINT, count_code_lines(file_spec, &#39;;&#39;, $
   DEBUG = 1, EXCPT_COND = excpt_cond)
          48</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>date_of_year</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports the date corresponding to the rank number <code>day_of_year</code> provided as input.</p></li>
<li><p><strong>Algorithm:</strong> This function computes the date (month and day) corresponding to the rank (day number within a civil year) provided as input, either for a common year (if the keyword parameter <code>YEAR</code> is not specified), or for that particular year if it is.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = date_of_year(day_of_year, month, day, $</code><br />
<code>YEAR = year, DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>day_of_year {INT} [I]:</code> The rank (day number) of a day in a year, a value expected to be in the range [1, 365] for a common year, or [1, 366] for a leap year.</p></li>
<li><p><code>month {INT} [O]:</code> The month in which this day falls.</p></li>
<li><p><code>day {INT} [O]:</code> The day within that month.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>YEAR = year {INT} [I] (Default: None):</code> The optional year number.</p></li>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> was set and if the optional output keyword parameter <code>EXCPT_COND</code> was provided in the call. The output positional parameters <code>month</code> and <code>day</code> provide the month and day numbers corresponding to the input positional parameter <code>day_of_year</code>, for a non-leap year if the optional input keyword parameter is either absent or points to a non-leap year. If this optional input keyword parameter is present in the call and points to a leap year, the output positional parameters are specific for that year.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameters <code>month</code> and <code>day</code> are set to <code>-1</code>.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input positional parameter <code>day_of_year</code> is not of numeric type.</p></li>
<li><p>Error 120: An exception condition occurred in <code>days_per_month.pro</code>.</p></li>
<li><p>Error 130: Input positional parameter <code>day_of_year</code> is invalid.</p></li>
<li><p>Error 200: Exception condition encountered in <code>CASE</code> statement, probably when optional keyword parameter <code>DEBUG</code> is not set.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>days_per_month.pro</code></p></li>
<li><p><code>is_leap.pro</code></p></li>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function cannot test and adjust for leap year if the year is not specified, so in the absence of the input keyword parameter <code>YEAR = year</code>, or if the specified year is not a leap year, the value <code>day_of_year = 366</code> is considered in error.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; res = date_of_year(60, month, day, $
   DEBUG = 1, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;month = &#39;, month, &#39; and day = &#39;, day
month =        3 and day =        1

IDL&gt; res = date_of_year(60, month, day, YEAR = 2004, $
   DEBUG = 1, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;month = &#39;, month, &#39; and day = &#39;, day
month =        2 and day =       29</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;10: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;-11&#8211;-20: Version 1.0 &#8212;&#8211; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;04&#8211;03: Version 1.2 &#8212; Update the code to use the new function<br />
<code>days_per_month.pro</code>.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>day_of_year</h2>
<ul>
<li><p><strong>Purpose:</strong> This function computes the rank (day number) of a date specified by the <code>month</code> and <code>day</code> numbers provided as input positional parameters, either for an arbitrary common year, or for the particular year specified in the optional keyword parameter <code>year</code>.</p></li>
<li><p><strong>Algorithm:</strong> By default, this function accumulates and returns the number of days between January 1 and the date specified by the positional parameters <code>month</code> and <code>day</code>, for a common (non leap) year. If the optional keyword parameter <code>year</code> is set to a particular value, this function computes the rank of the specified date taking into account the leap status of that year.</p></li>
<li><p><strong>Syntax:</strong> <code>res = day_of_year(month, day, YEAR = year, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>month {INT} [I]:</code> The month of the date to characterize, where January is 1, February is 2, <span class="math inline">&#8230;</span> and December is 12.</p></li>
<li><p><code>day {INT} [I]:</code> The day within the month of the date to characterize, where the first day of the month is 1 and the last day of the month is either 28, 30 or 31, depending on the month.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>YEAR = year {INT} [I]:</code> The specific year for which the computation must be carried out.</p></li>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns the rank number of the specified day in a common year (if the keyword <code>year</code> was not set) or in the specified <code>year</code> (if the keyword was set), and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns <code>-1</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>month</code> is not a scalar variable of type numeric.</p></li>
<li><p>Error 120: Positional parameter <code>month</code> is invalid: Must be contained in [1, 12].</p></li>
<li><p>Error 130: Keyword parameter <code>year</code> is not a scalar variable of type numeric.</p></li>
<li><p>Error 140: Keyword parameter <code>year</code> is invalid: Must be contained within [1582, 2100].</p></li>
<li><p>Error 150: Positional parameter <code>day</code> is not a scalar variable of type numeric.</p></li>
<li><p>Error 160: Positional parameter <code>day</code> is invalid: Must be contained in the interval [1, num_days[month]].</p></li>
<li><p>Error 200: An exception condition occurred in <code>days_per_month.pro</code>.</p></li>
<li><p>Error 210: An exception condition occurred in <code>days_per_month.pro</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>days_per_month.pro</code></p></li>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>is_scalar.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> By default, this function accumulates and returns the number of days between January 1 and the date specified by the positional parameters <code>month</code> and <code>day</code>, for a common (non leap) year. If the optional keyword parameter <code>year</code> is set to a particular value, this routine computes the rank of the specified date taking into account the leap status of that <code>year</code>.</p></li>
<li><p><strong>Note 2:</strong> If <code>day</code> is set to 29 (implying a leap year), the keyword parameter <code>year</code> must be provided, otherwise the function returns an error code, provided the optional input keyword parameter <code>DEBUG</code> is set.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; res = day_of_year(3, 25, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
      84
IDL&gt; PRINT, &#39;excpt_cond = &gt;&#39; + excpt_cond + &#39;&lt;&#39;
excpt_cond = &gt;&lt;

IDL&gt; res = day_of_year(6, 13, YEAR = 2000, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
     165
IDL&gt; PRINT, &#39;excpt_cond = &gt;&#39; + excpt_cond + &#39;&lt;&#39;
excpt_cond = &gt;&lt;

IDL&gt; res = day_of_year(2, 29, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
      -1
IDL&gt; PRINT, &#39;excpt_cond = &#39; + excpt_cond
excpt_cond = Error 134 in day_of_year: Input positional parameter
   day is invalid: Must be contained in [1, num_days[month]].

IDL&gt; res = day_of_year(2, 29, YEAR = 2016, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
      60
IDL&gt; PRINT, &#39;excpt_cond = &gt;&#39; + excpt_cond + &#39;&lt;&#39;
excpt_cond = &gt;&lt;

[Note: Without the DEBUG option, the result is incorrect
(2015 is not a leap year) and the function does not report
the problem.]
IDL&gt; res = day_of_year(2, 29, YEAR = 2015, DEBUG = 0, $
   EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
      60
IDL&gt; PRINT, &#39;excpt_cond = &gt;&#39; + excpt_cond + &#39;&lt;&#39;
excpt_cond = &gt;&lt;</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>days_per_month</h2>
<ul>
<li><p><strong>Purpose:</strong> This function sets the number of days per month, for either a generic or a particular year (specified through the keyword <code>year</code>), in which case it adjusts the number of days in February if that year is a leap year.</p></li>
<li><p><strong>Algorithm:</strong> This function defines the output positional parameter <code>num_days</code> as a 13-element <code>INT</code> array, sets <code>num_days[0]</code> to 365 and assigns the default number of days to each month of the year in array elements 1 to 12. If the keyword parameter <code>year</code> is provided, the function checks whether that year is a leap year and adjusts the number of days in February as well as the total number of days in the year accordingly.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = days_per_month(num_days, YEAR = year, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>num_days {INT} [O]:</code> Array containing the number of days of each month, as well as the total number of days in the year.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>YEAR = year {INT} [I] (Default value: None):</code> Optional year number in the range [1584, 2100], for the purpose of determining if that year is a leap year.</p></li>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> was set and if the optional output keyword parameter <code>EXCPT_COND</code> was provided in the call. The output positional parameter <code>num_days</code> contains the results generated by this function.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameter <code>num_days</code> may be undefined or useless.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input keyword parameter <code>year</code> is invalid: it must be within the range [1582, 2100].</p></li>
<li><p>Error 120: An exception condition occurred in <code>is_leap.pro</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_leap.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong> None.</p></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; year = 2016
IDL&gt; rc = days_per_month(num_days, YEAR = year, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;rc = &#39; + strstr(rc) + &#39;, excpt_cond = &gt;&#39; + $
   excpt_cond + &#39;&lt;&#39;
rc = 0, excpt_cond = &gt;&lt;
IDL&gt; PRINT, &#39;num_days = &#39;, num_days, FORMAT = &#39;(A, 13I5)&#39;
num_days = 366  31  29  31  30  31  30  31  31  30  31  30  31</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;03&#8211;24: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2018&#8211;03&#8211;28: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>discrete_integral</h2>
<ul>
<li><p><strong>Purpose:</strong> This function returns the integral of a mathematical function provided as a discrete set of <code>(x, y)</code> points.</p></li>
<li><p><strong>Algorithm:</strong> This function calculates the &#8216;area under the curve&#8217; defined by the discrete set of <code>(x, y)</code> points, assuming a simple linear interpolation between those points (the so-called &#8220;trapezoidal rule&#8221;). The optional <code>BASELINE</code> keyword allows for adjusting the arbitrary constant inherent with the estimation of a definite integral.</p></li>
<li><p><strong>Syntax:</strong> <code>res = discrete_integral(x, y, BASELINE = baseline, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>x {FLOAT} [I]:</code> The array of independent variable values.</p></li>
<li><p><code>y {FLOAT} [I]:</code> The array of dependent variable values.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>BASELINE = baseline {FLOAT} [I] (Default value: 0.0):</code> The reference dependent variable value from which the &#8216;area under the curve&#8217; will be computed.</p></li>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>FLOAT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns the value of the definite integral of the function defined by the discrete set of <code>(x, y)</code> points, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> was set and if the optional output keyword parameter <code>EXCPT_COND</code> was provided in the call.</p></li>
<li><p>If an exception condition has been detected, this function returns <code>-9999.00</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input positional parameters <code>x</code> and <code>y</code> must be numeric.</p></li>
<li><p>Error 120: Input positional parameters <code>x</code> and <code>y</code> must be arrays containing at least 2 elements.</p></li>
<li><p>Error 130: Input positional parameters <code>x</code> and <code>y</code> must be arrays of the same length.</p></li>
<li><p>Error 140: Optional keyword <code>baseline</code> must be of numeric type.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function implements a strict trapezoidal rule to estimate the integral of the function provided as a discrete set of <code>(x, y)</code> points. If all <code>y</code> values are larger than the <code>baseline</code>, the result may underestimate the integral where the function is concave, and overestimate it where the function is convex, compared to the outcome of a more sophisticated approach, for instance by fitting a smooth curve through the points.</p></li>
<li><p><strong>Note 2:</strong> This function performs all computations in <code>DOUBLE</code> precision, and returns the result as a single precision <code>FLOAT</code> value.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; x = [1.0, 2.0]
IDL&gt; y = [4.0, 6.0]
IDL&gt; res = discrete_integral(x, y, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;res = &#39;, res
res =       5.00000</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p><a href="https://en.wikipedia.org/wiki/Trapezoidal_rule" class="uri">https://en.wikipedia.org/wiki/Trapezoidal_rule</a>, accessed on 24 March 2018.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;03&#8211;24: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2018&#8211;03&#8211;25: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>first_char</h2>
<ul>
<li><p><strong>Purpose:</strong> This function returns the first character of the input positional parameter <code>arg_str</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on <code>IDL</code> built-in string functions to extract the desired character.</p></li>
<li><p><strong>Syntax:</strong> <code>res = first_char(arg_str, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg_str {STRING} [I]:</code> An arbitrary string expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>STRING</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns the first character of the input positional parameter, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns a null string, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>arg_str</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 120: Positional parameter <code>arg_str</code> does not contain at least one character.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong> None.</p></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; PRINT, first_char(&#39;Hello World&#39;)
H

IDL&gt; PRINT, &#39;&gt;&#39; + first_char(3.14, /DEBUG, $
   EXCPT_COND = excpt_cond) + &#39;&lt;&#39;
&gt;&lt;
IDL&gt; PRINT, &#39;excpt_cond = &#39; + excpt_cond
excpt_cond = Error 110 in FIRST_CHAR: Input
   positional parameter must be of type STRING.

[In the following example, variable xyz is undefined.]
IDL&gt; PRINT, &#39;&gt;&#39; + first_char(xyz, /DEBUG, $
   EXCPT_COND = excpt_cond) + &#39;&lt;
&gt;&lt;
IDL&gt; PRINT, &#39;excpt_cond = &#39; + excpt_cond
excpt_cond = Error 110 in FIRST_CHAR: Input
   positional parameter must be of type STRING.</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>force_path_sep</h2>
<ul>
<li><p><strong>Purpose:</strong> This function trims the input positional parmeter <code>dir_spec</code> of any white space at the front and at the end of the string, and ensures that it is terminated by the path segment separator character for the current operating system. If the input positional parmeter <code>dir_spec</code> is already terminated by that character, the function returns the input positional parameter.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on <code>IDL</code> built-in functions <code>STRTRIM()</code> and <code>PATH_SEP()</code> to deliver its outcome.</p></li>
<li><p><strong>Syntax:</strong> <code>res = force_path_sep(dir_spec, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>dir_spec {STRING} [I/O]:</code> An arbitrary directory or path specification.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>STRING</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns the input positional parameter <code>dir_spec</code> duly terminated by the appropriate path separator, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns a null string, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>dir_spec</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 120: Positional parameter <code>dir_spec</code> must contain at least 1 character.</p></li>
<li><p>Error 200: An exception condition occurred in <code>last_char.pro</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>last_char.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong> None.</p></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; PRINT, force_path_sep(&#39;   ~/Desktop   &#39;)
~/Desktop/

IDL&gt; PRINT, force_path_sep(&#39;~/Desktop/&#39;)
~/Desktop/

IDL&gt; print, force_path_sep(&#39;Hello&#39;)
Hello/</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>get_dirs_sizes</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports the size of folders matching the input positional parameter <code>dir_patt</code>, if they exist.</p></li>
<li><p><strong>Algorithm:</strong> This function searches for folder names matching the pattern <code>dir_patt</code>, and, if any are found, spawns a <code>Bash</code> shell script using the <code>Linux</code> command <code>du</code> to report on their sizes.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = get_dirs_sizes(dir_patt, n_dirs, dirs_names, dirs_sizes, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>dir_patt {STRING} [I]:</code> A pattern of folder names.</p></li>
<li><p><code>n_dirs {INT} [O]:</code> The number of matching folders.</p></li>
<li><p><code>dirs_names {STRING array} [O]:</code> The names of the matching folders.</p></li>
<li><p><code>dirs_sizes {STRING array} [O]:</code> A string array containing the sizes of the matching folders.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> was set and if the optional output keyword parameter <code>EXCPT_COND</code> was provided in the call. The output positional parameters <code>n_dirs</code>, <code>dirs_names</code> and <code>dirs_sizes</code> contain the desired information.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameters <code>n_dirs</code>, <code>dirs_names</code> and <code>dirs_sizes</code> may be inexistent, incomplete or incorrect.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>dir_patt</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 120: Positional parameter <code>dir_patt</code> cannot be a null <code>STRING</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>set_white.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function may not work in a MS Windows environment, which lacks the <code>du</code> command.</p></li>
<li><p><strong>Note 2:</strong> The output positional parameter <code>dirs_sizes</code> is of type <code>STRING</code> despite its name and purpose suggesting a number, because it also contains a size unit such as &#8216;M&#8217; for Megabytes, or &#8216;G&#8217; for Gigabytes.</p></li>
<li><p><strong>Note 3:</strong> If no folders are found, the output positional parameter <code>n_dirs</code> is set to <code>0</code> while <code>dirs_names</code> and <code>dirs_sizes</code> are both set to empty <code>STRING</code> arrays.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; rc = get_dirs_sizes(&#39;/Volumes/MISR-HR/P16*&#39;, n_dirs, $
   dirs_names, dirs_sizes, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;rc = &#39; + strstr(rc) + &#39;, excpt_cond = &gt;&#39; + $
   excpt_cond + &#39;&lt;&#39;
rc = 0, excpt_cond = &gt;&lt;
IDL&gt; PRINT, &#39;n_dirs = &#39; + strstr(n_dirs)
n_dirs = 3
IDL&gt; PRINT, dirs_names
/Volumes/MISR-HR/P167/
/Volumes/MISR-HR/P168/
/Volumes/MISR-HR/P169/
IDL&gt; PRINT, dirs_sizes
81G 557G 337G</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;06: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>get_disks_sizes</h2>
<ul>
<li><p><strong>Purpose:</strong> This function retrieves the name, total capacity, used space and available space of each of the disks mounted on the current computer and matching the optional pattern <code>DIR</code>, and passes that information to the calling routine through the output positional parameter <code>disks_sizes</code>. If the optional keyword parameter <code>PRINTIT</code> is set, this information is also printed on the console.</p></li>
<li><p><strong>Algorithm:</strong> This function spawns a Linux <code>df</code> command to the operating system, extracts the desired information from the outcome, and uses it to populate the 2-dimensional output array <code>disks_sizes</code>.</p></li>
<li><p><strong>Syntax:</strong> <code>res = get_disks_sizes(disks_sizes, DIR = dir, PRINTIT = printit, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>disks_sizes {STRING array} [O]:</code> A 2-dimensional array containing size information for each disk mounted on the current computer.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DIR = dir {STRING} [I] (Default: &#8221;):</code> The name pattern of the disk(s) to be documented.</p></li>
<li><p><code>PRINTIT = printit {INT} [I] (Default: 0):</code> Flag to activate (1) or skip (0) the printing of the outcome on the console.</p></li>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided in the call. The output positional parameter <code>disks_sizes</code> is set as a 2-dimensional <code>STRING</code> array <code>disks_sizes[n_disks, n_items]</code> whose elements have the following meanings:</p>
<ul>
<li><p><code>N_ELEMENTS(disks_sizes[*, 0])</code> is the number of currently mounted disks meeting the optional selection criterion <code>dir</code>,</p></li>
<li><p><code>disks_sizes[i, 0]</code> contains the name of the mount point for disk <code>i</code>,</p></li>
<li><p><code>disks_sizes[i, 1]</code> contains the total capacity of the disk <code>i</code>,</p></li>
<li><p><code>disks_sizes[i, 2]</code> contains the space already used on disk <code>i</code>, and</p></li>
<li><p><code>disks_sizes[i, 3]</code> contains the space remaining available on disk <code>i</code>.</p></li>
</ul></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameter <code>disks_sizes</code> may be inexistent, incomplete or incorrect.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: The optional keyword parameter <code>dir</code> must be of type <code>STRING</code>.</p></li>
<li><p>Error 120: An exception condition occurred in the spawning of the <code>df</code> command.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>set_white.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function relies on Linux&#8217;s <code>df</code> command, so it will only work within the macOS or Linux environments.</p></li>
<li><p><strong>Note 2:</strong> The 3 numbers reported for each disk found represent the total space, the used space and the remaining available space, respectively.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; dir = &#39;MISR*&#39;
IDL&gt; rc = get_disks_sizes(disks_sizes, DIR = dir, $
   /PRINT, /DEBUG, EXCPT_COND = excpt_cond)
There are 2 disks mounted on MicMac2:
        /Volumes/MISR-HR       1.8Ti       1.8Ti       3.6Gi
     /Volumes/MISR_Data3       3.6Ti       3.3Ti       379Gi</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;03&#8211;29: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;04&#8211;02: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2017&#8211;04&#8211;04: Version 1.1 &#8212; Update the code and documentation to provide the desired information through a positional parameter rather than the return value (now used for error reporting).</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;02&#8211;28: Version 2.01 &#8212; Documentation update.</p></li>
</ul></li>
</ul>
<h2>get_host_info</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports on the names of the operating system and the computer on which it is running.</p></li>
<li><p><strong>Algorithm:</strong> This function does not require any input; it relies on the <code>IDL</code> <code>!VERSION</code> internal variable and on either the <code>hostname</code> command (on computers running under <code>Linux</code> or <code>Mac</code>), or the environmental variable <code>COMPUTERNAME</code> (on computers running under <code>MS Windows</code>) to define the value of the output positional parameters.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = get_host_info(os_name, comp_name, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>os_name {STRING} [O]:</code> The name of the underlying operating system; under <code>IDL</code> Version 8.7, this output positional parameter is either <code>linux</code>, or <code>darwin</code>, or <code>Win32</code>.</p></li>
<li><p><code>comp_name {STRING} [O]:</code> The name of the computer executing this routine.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided in the call. The output positional parameters <code>os_name</code> and <code>comp_name</code> contain the results generated by this function.</p></li>
<li><p>If an exception condition has been detected, this function returns the warning code <code>98</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameters <code>os_name</code> and <code>comp_name</code> may be inexistent, incomplete or incorrect.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 98: The operating system or the computer is not recognized.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The logic implemented in this function may need to be updated either if one of the operating systems changes its naming convention, or more or different operating systems should be considered, or the mechanism to retrieve the name of the computer changes.</p></li>
<li><p><strong>Note 2:</strong> On computers running under the Microsoft Windows family of operating systems, the user should verify that the environment variable <code>COMPUTERNAME</code> exists prior to using this function.</p></li>
<li><p><strong>Note 3:</strong> Exception condition <code>98</code> does not need to imply a processing interruption, as the input and output folders normally provided by default on the basis of this host information can be overridden explicitly with optional input keyword parameters.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; rc = get_host_info(os_name, comp_name)
IDL&gt; PRINT, &#39;os_name = &#39;, os_name
os_name = darwin
IDL&gt; PRINT, &#39;comp_name = &#39;, comp_name
comp_name = MicMac2</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;07&#8211;03: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2018&#8211;07&#8211;05: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;07&#8211;10: Version 1.1 &#8212; Documentation update.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;02&#8211;26: Version 2.01 &#8212; Minor coding update: Add requirement to call this function with 2 output positional parameters.</p></li>
</ul></li>
</ul>
<h2>haversine</h2>
<ul>
<li><p><strong>Purpose:</strong> This function computes the haversine distance between the two locations specified by their latitudes and longitudes in decimal degrees.</p></li>
<li><p><strong>Algorithm:</strong> This function implements the classical haversine formula, as described in the references below.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = haversine(lat_1, lon_1, lat_2, lon_2, $</code><br />
<code>distance, DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>lat_1 {DOUBLE} [I]:</code> The latitude of the first location, in decimal degrees.</p></li>
<li><p><code>lon_1 {DOUBLE} [I]:</code> The longitude of the first location, in decimal degrees.</p></li>
<li><p><code>lat_2 {DOUBLE} [I]:</code> The latitude of the second location, in decimal degrees.</p></li>
<li><p><code>lon_2 {DOUBLE} [I]:</code> The longitude of the second location, in decimal degrees.</p></li>
<li><p><code>distance {DOUBLE} [O]:</code> The distance between the two locations, in m, following a great circle on a spherical Earth.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided in the call. The distance between the 2 input locations is provided in output positional parameter.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The distance between the 2 locations may be undefined, incomplete or incorrect.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: The input positional parameter <code>lat_1</code> is not of type <code>FLOAT</code> or <code>DOUBLE</code>.</p></li>
<li><p>Error 112: The input positional parameter <code>lat_1</code> must be in the range <code>[-90.0D, 90.0D]</code>.</p></li>
<li><p>Error 120: The input positional parameter <code>lon_1</code> is not of type <code>FLOAT</code> or <code>DOUBLE</code>.</p></li>
<li><p>Error 122: The input positional parameter <code>lon_1</code> must be in the range <code>[-180.0D, 180.0D]</code>.</p></li>
<li><p>Error 130: The input positional parameter <code>lat_2</code> is not of type <code>FLOAT</code> or <code>DOUBLE</code>.</p></li>
<li><p>Error 132: The input positional parameter <code>lat_2</code> must be in the range <code>[-90.0D, 90.0D]</code>.</p></li>
<li><p>Error 140: The input positional parameter <code>lon_2</code> is not of type <code>FLOAT</code> or <code>DOUBLE</code>.</p></li>
<li><p>Error 142: The input positional parameter <code>lon_2</code> must be in the range <code>[-180.0D, 180.0D]</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_double.pro</code></p></li>
<li><p><code>is_float.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The distance between two locations returned by this function does not take into account any differences in altitude: it only reports on the distance between the specified latitudes and longitudes, on a spherical Earth, at the mean sea level.</p></li>
<li><p><strong>Note 2:</strong> The outcome of this routine is quite sensitive to the number of decimal places and the numerical precision with which the input latitudes and longitudes are provided: this is particularly important for small distances.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; lat_1 = -27.34439555D
IDL&gt; lon_1 = 30.13553714D
IDL&gt; lat_2 = -27.34400537D
IDL&gt; lon_2 = 30.13680177D
IDL&gt; rc = haversine(lat_1, lon_1, lat_2, lon_2, distance)
IDL&gt; PRINT, &#39;distance = &#39; + strstr(distance)
distance = 132.22839</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p>https://www.movable-type.co.uk/scripts/latlong.html, visited on 6 April 2019.</p></li>
<li><p>https://en.wikipedia.org/wiki/Earth_radius, visited on 6 April 2019.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2019&#8211;04&#8211;06: Version 1.0 &#8212; Initial release.</p></li>
<li><p>2019&#8211;04&#8211;06: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_dir</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>dir_spec</code> is a directory or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>FILEINFO()</code>.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_dir(dir_spec, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>dir_spec {STRING} [I]:</code> An arbitrary directory specification.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>1</code> if the input positional parameter <code>dir_spec</code> is a directory, and <code>0</code> otherwise, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided in the call.</p></li>
<li><p>If an exception condition has been detected, this function returns <code>-1</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>dir_spec</code> is not of type <code>STRING</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The input positional parameter <code>dir_spec</code> can include wild characters (<code>IDL</code>-allowed regular expressions): see the third example below, but it cannot be an explicit array of directories.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; dir_spec = &#39;~/Desktop&#39;
IDL&gt; PRINT, is_dir(dir_spec)
       1

IDL&gt; dir_spec = &#39;~/Documents/MySoftware/Test_dir/Test_file.txt&#39;
IDL&gt; PRINT, is_dir(dir_spec, /DEBUG, EXCPT_COND = excpt_cond)
       0

IDL&gt; dir_spec = &#39;/Volumes/MISR_Data*/P*/&#39;
IDL&gt; PRINT, is_dir(dir_spec, DEBUG = 1, EXCPT_COND = excpt_cond)
       1</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_file</h2>
<ul>
<li><p><strong>Purpose:</strong> This function returns <code>1</code> if the input positional parameter <code>file_spec</code> is a regular file, and <code>0</code> otherwise.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> built-in function <code>FILEINFO()</code>.</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_finput positional parameter_spec, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>file_spec {STRING} [I]:</code> An arbitrary file specification.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>1</code> if the input positional parameter <code>file_spec</code> is a regular file and <code>0</code> otherwise, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided in the call.</p></li>
<li><p>If an exception condition has been detected, this function returns <code>-1</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>file_spec</code> is not of type <code>STRING</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong> None.</p></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; file_spec = &#39;~/Desktop&#39;
IDL&gt; PRINT, is_file(file_spec)
      0

IDL&gt; file_spec = &#39;~/Codes/Test_dir/Test_file.txt&#39;
IDL&gt; PRINT, is_file(file_spec, /DEBUG, EXCPT_COND = excpt_cond)
      1</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_leap</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>year</code> is a leap year or not.</p></li>
<li><p><strong>Algorithm:</strong> For dates after 4 October 1582, a year that is exactly divisible by four is a leap year, except that years which are exactly divisible by 100 are not leap years, while centurial years that are exactly divisible by 400 are leap years (See the references section below).</p></li>
<li><p><strong>Syntax:</strong> <code>res = is_leap(year, DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>year {INT} [I]:</code> The year to inspect.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>1</code> if the input positional parameter <code>year</code> is a leap year or <code>0</code> it is not a leap year, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns <code>-1</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>year</code> is not of type numeric.</p></li>
<li><p>Error 120: Positional parameter <code>year</code> is anterior to 1582.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function is applicable only to dates of the Gregorian calendar, i.e., years occurring after 4 October 1582.</p></li>
<li><p><strong>Note 2:</strong> Fractional years are rounded off (<code>FLOOR</code>) by ignoring the decimal part: See the second example below.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; res = is_leap(2015, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res, &#39;   &gt;&#39; + excpt_cond + &#39;&lt;&#39;
       0   &gt;&lt;

IDL&gt; res = is_leap(2016.7, DEBUG = 1, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res, &#39;   &gt;&#39; + excpt_cond + &#39;&lt;&#39;
       1   &gt;&lt;

IDL&gt; res = is_leap(512, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res, &#39;   &gt;&#39; + excpt_cond + &#39;&lt;&#39;
      -1   &gt;Error 120 in IS_LEAP: Input input positional
      parameter 512 is anterior to 1582.&lt;</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p>Web site: <code>https://en.wikipedia.org/wiki/Leap_year</code>, accessed on 2017-10-30.</p></li>
<li><p><code>IDL</code> documentation for built-in routine <code>JULDAY</code>.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_lowercase</h2>
<ul>
<li><p><strong>Purpose:</strong> This function determines whether the input positional parameter <code>char</code> is set in lower case letter or not.</p></li>
<li><p><strong>Algorithm:</strong> This function checks whether the <code>BYTE</code> value of the character <code>char</code> lies in the range [97, 122].</p></li>
<li><p><strong>Syntax:</strong> <code>rc = is_lowercase(char, DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>char {STRING} [I]:</code> The single character to be tested.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>1</code> if the input positional parameter is set in lower case, <code>0</code> otherwise, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns an error code larger than <code>1</code> and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>char</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 120: Positional parameter <code>char</code> is not of length 1.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong> None.</p></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; res = is_lowercase(&#39;b&#39;, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;res = &#39;, res, &#39; excpt_cond = &gt;&#39; + excpt_cond + &#39;&lt;&#39;
res =        1 excpt_cond = &gt;&lt;

IDL&gt; res = is_lowercase(&#39;ab&#39;, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;res = &#39;, res, &#39; excpt_cond = &gt;&#39; + excpt_cond + &#39;&lt;&#39;
res =      120 excpt_cond = &gt;Error 120 in IS_LOWERCASE:
   Input positional parameter cannot be the null string or
   contain more than 1 character.&lt;</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;18: Version 1.0 &#8212; Initial release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_readable</h2>
<p>input positional parameter</p>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>file_spec</code> exists or not, and if it exists, whether it points to a directory or file that is readable or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on <code>IDL</code> internal functions to determine the status of the directory or file provided as input positional parameter <code>file_spec</code>.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = is_readable(file_spec, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>file_spec {STRING} [I]:</code> The file specification (path and/or file name) to be checked for reading.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong> This function returns</p>
<ul>
<li><p><code>1</code> if the file or directory provided as the input positional parameter <code>file_spec</code> exists and is readable; the output keyword parameter <code>excpt_cond</code> is set to a null string.</p></li>
<li><p><code>0</code> if this file or directory exists but is unreadable; the output keyword parameter <code>excpt_cond</code> contains a message to this effect.</p></li>
<li><p><code>-1</code> if an exception condition has been detected; the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered.</p></li>
<li><p><code>-2</code> if this file or directory does not exist; the output keyword parameter <code>excpt_cond</code> contains a message to this effect.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>file_spec</code> is not of type <code>STRING</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> Since the purpose of this function is to check the existence and readability of the input positional parameter <code>file_spec</code>, all tests are performed irrespective of the setting of the input keyword parameter <code>DEBUG</code>. The keywords <code>DEBUG</code> and <code>EXCPT_COND</code> are included for consistency, and to allow reporting of the exception condition if one is encountered.</p></li>
<li><p><strong>Note 2:</strong> If the input positional parameter <code>file_spec</code> does not contain a path component (absolute or relative), the file is assumed to be located in the current working directory.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; rc = is_readable(&#39;~/Desktop&#39;, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, rc, &#39;,   &gt;&#39; + excpt_cond + &#39;&lt;&#39;
1,   &gt;&lt;

IDL&gt; rc = is_readable(&#39;~/Codes/Test_dir/unreadable.txt&#39;, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, rc, &#39;,   &gt;&#39; + excpt_cond + &#39;&lt;&#39;
0,   &gt;The file ~/Codes/Test_dir/unreadable.txt exists
   but is unreadable.&lt;

IDL&gt; rc = is_readable(234, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, rc, &#39;,   &gt;&#39; + excpt_cond + &#39;&lt;&#39;
-1,   &gt;Error 110 in IS_READABLE: Input positional
   parameter file_spec is not of type string.&lt;

IDL&gt; rc = is_readable(&#39;~/Desktop/missing_file.txt&#39;, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, rc, &#39;,   &gt;&#39; + excpt_cond + &#39;&lt;&#39;
-2,   &gt;&lt;</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;04&#8211;24: Version 1.2 &#8212; Update the function to return <code>0</code> but no exception condition if the input positional parameter exists but is unreadable.</p></li>
<li><p>2018&#8211;05&#8211;14: Version 1.3 &#8212; Add return code to indicate the input positional parameter does not exist, and update the documentation.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2018&#8211;06&#8211;22: Version 1.6 &#8212; Improve diagnostic messages.</p></li>
<li><p>2018&#8211;08&#8211;15: Version 1.7 &#8212; Return non-empty <code>excpt_cond</code> values only when errors are encountered (i.e., only when <code>rc = -1</code>, and not as warning or information messages).</p></li>
<li><p>2018&#8211;08&#8211;28: Version 1.8 &#8212; Return empty <code>excpt_cond</code> value only when <code>file_spec</code> exists and is readable.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_uppercase</h2>
<ul>
<li><p><strong>Purpose:</strong> This function determines whether the input positional parameter <code>char</code> is set in upper case letter or not.</p></li>
<li><p><strong>Algorithm:</strong> This function checks whether the <code>BYTE</code> value of the character <code>char</code> lies in the range [65, 90].</p></li>
<li><p><strong>Syntax:</strong> <code>rc = is_uppercase(char, DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>char {STRING} [I]:</code> The single character to be tested.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>1</code> if the input positional parameter is set in upper case, <code>0</code> otherwise, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns an error code larger than <code>1</code> and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>char</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 120: Positional parameter <code>char</code> is not of length 1.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong> None.</p></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; res = is_uppercase(&#39;C&#39;, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;res = &#39;, res, &#39; excpt_cond = &gt;&#39; + excpt_cond + &#39;&lt;&#39;
res =        1 excpt_cond = &gt;&lt;

IDL&gt; res = is_uppercase(&#39;c&#39;, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;res = &#39;, res, &#39; excpt_cond = &gt;&#39; + excpt_cond + &#39;&lt;&#39;
res =        0 excpt_cond = &gt;&lt;</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;18: Version 1.0 &#8212; Initial release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>is_writable</h2>
<ul>
<li><p><strong>Purpose:</strong> This function reports whether the input positional parameter <code>file_spec</code> exists or not, and if it exists, whether it points to a directory or file that is writable or not.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on <code>IDL</code> internal functions to determine the status of the directory or file provided as input positional parameter <code>file_spec</code>.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = is_writable(file_spec, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>file_spec {STRING} [I]:</code> The file specification (path and/or file name) to be checked for writing.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong> This function returns</p>
<ul>
<li><p><code>1</code> if the file or directory provided as the input positional parameter <code>file_spec</code> exists and is writable; the output keyword parameter <code>excpt_cond</code> is set to a null string.</p></li>
<li><p><code>0</code> if this file or directory exists but is unwritable; the output keyword parameter <code>excpt_cond</code> contains a message to this effect.</p></li>
<li><p><code>-1</code> if an exception condition has been detected; the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered.</p></li>
<li><p><code>-2</code> if this file or directory does not exist; the output keyword parameter <code>excpt_cond</code> contains a message to this effect.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>file_spec</code> is not of type <code>STRING</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> Since the purpose of this function is to check the existence and writability of the input positional parameter <code>file_spec</code>, all tests are performed irrespective of the setting of the input keyword parameter <code>DEBUG</code>. The keywords <code>DEBUG</code> and <code>EXCPT_COND</code> are included for consistency, and to allow reporting of the exception condition if one is encountered.</p></li>
<li><p><strong>Note 2:</strong> If the input positional parameter <code>file_spec</code> does not contain a path component (absolute or relative), the file is assumed to be located in the current working directory.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; rc = is_writable(&#39;~/Desktop&#39;, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, rc, &#39;,   &gt;&#39; + excpt_cond + &#39;&lt;&#39;
1,   &gt;&lt;

IDL&gt; rc = is_writable(&#39;~/Codes/Test_dir/unwritable.txt&#39;,
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, rc, &#39;,   &gt;&#39; + excpt_cond + &#39;&lt;&#39;
0,   &gt;The file ~/Codes/Test_dir/unwritable.txt exists but is
   unwritable.&lt;

IDL&gt; rc = is_writable(3, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, rc, &#39;,   &gt;&#39; + excpt_cond + &#39;&lt;&#39;
-1,   &gt;Error 110 in IS_WRITABLE: Input positional parameter
   file_spec is not of type string.&lt;</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;04&#8211;24: Version 1.2 &#8212; Update the function to return <code>0</code> but no exception condition if the input positional parameter exists but is unwritable.</p></li>
<li><p>2018&#8211;05&#8211;13: Version 1.3 &#8212; Add return code to indicate the input positional parameter does not exist, and update the documentation.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2018&#8211;06&#8211;22: Version 1.6 &#8212; Improve diagnostic messages.</p></li>
<li><p>2018&#8211;08&#8211;15: Version 1.7 &#8212; Return non-empty <code>excpt_cond</code> values only when errors are encountered (i.e., only when <code>rc = -1</code>, and not as warning or information messages).</p></li>
<li><p>2018&#8211;08&#8211;28: Version 1.8 &#8212; Return empty <code>excpt_cond</code> value only when <code>file_spec</code> exists and is writable.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>iso2jul</h2>
<ul>
<li><p><strong>Purpose:</strong> This function converts an ISO 8601/W3C date, specified as a <code>STRING</code>, into a Julian date provided as a <code>DOUBLE</code> floating point number.</p></li>
<li><p><strong>Algorithm:</strong> This function extracts the elements of the ISO 8601/W3C date specification (<code>yyyy-mm-ddThh:mm:ssZ</code>) and relies on the <code>IDL</code> function <code>JULDAY</code> to generate the corresponding Julian day number.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = iso2jul(isodate, juldate, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>isodate {STRING} [O]:</code> The input date formatted as <code>yyyy-mm-ddThh:mm:ssZ</code>.</p></li>
<li><p><code>juldate {DOUBLE} [I]:</code> The output Julian day number.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided in the call. The output positional parameter <code>juldate</code> contains the Julian day number corresponding to the input positional parameter <code>isodate</code>.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameter <code>juldate</code> may be undefined, inexistent, incomplete or useless.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input positional parameter <code>isodate</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 200: The input positional parameter <code>isodate</code> is incorrectly formatted: it must contain 2 strings separated by <code>T</code>.</p></li>
<li><p>Error 210: The input positional parameter <code>isodate</code> is incorrectly formatted: the date must contain 3 strings separated by <code>-</code>.</p></li>
<li><p>Error 220: The input positional parameter <code>isodate</code> is incorrectly formatted: the time must contain 3 strings separated by <code>:</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>chk_isodate.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> Julian days start at noon local time, so the first 12 hours of a particular civilian day belong to the second half of one Julian day, and the last 12 hours belong to the first half of the next Julian day. See the examples below.</p></li>
<li><p><strong>Note 2:</strong> By default, the <code>IDL</code> function <code>JULDAY</code> returns a <code>LONG</code> integer if the date is specified only using the month, day and year numbers, and as a <code>DOUBLE</code> floating point if the date specification includes the hour, minute or second.</p></li>
<li><p><strong>Note 3:</strong> By default, <code>IDL</code> prints large <code>DOUBLE</code> floating point numbers such as Julian days for contemporary dates with a single decimal digit and rounds the actual numbers in the process. As a result, the Julian day number may appear to be the same before and after noon: to witness the change, use a format statement to force the output of at least two or more decimals. See the examples below.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; isodate = &#39;1953-06-13T11:00:00Z&#39;
IDL&gt; rc = iso2jul(isodate, juldate, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;juldate = &#39;, juldate
juldate =        2434542.0
IDL&gt; PRINT, &#39;juldate = &#39;, juldate, FORMAT = &#39;(A, D12.4)&#39;
juldate = 2434541.9583

IDL&gt; isodate = &#39;1953-06-13T13:00:00Z&#39;
IDL&gt; rc = iso2jul(isodate, juldate, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;juldate = &#39;, juldate
juldate =        2434542.0
IDL&gt; PRINT, &#39;juldate = &#39;, juldate, FORMAT = &#39;(A, D12.4)&#39;
juldate = 2434542.0417</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p><a href="https://www.w3.org/TR/NOTE-datetime" class="uri">https://www.w3.org/TR/NOTE-datetime</a>, accessed on 21 November 2018.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;11&#8211;22: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2018&#8211;11&#8211;30: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>jul2iso</h2>
<ul>
<li><p><strong>Purpose:</strong> This function converts a Julian date, specified as a floating point number in <code>DOUBLE</code> precision, into an ISO 8601/W3C date, specified as a <code>STRING</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on the <code>IDL</code> program <code>CALDAT</code> to extract the date elements from the input Julian date, and reformats those into the ISO 8601/W3C date specification (<code>yyyy-mm-ddThh:mm:ssZ</code>).</p></li>
<li><p><strong>Syntax:</strong> <code>rc = jul2iso(juldate, isodate, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>juldate {DOUBLE} [I]:</code> The input Julian day number.</p></li>
<li><p><code>isodate {STRING} [O]:</code> The output date, formatted as per the ISO 8601/W3C specifications.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided in the call. The output positional parameter <code>isodate</code> contains the date corresponding to the input Julian day number.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameter <code>isodate</code> may be undefined, inexistent, incomplete or useless.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input positional parameter juldate is not of type <code>DOUBLE</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_double.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> Julian days start at noon local time, so the first 12 hours of a particular civilian day belong to the second half of one Julian day, and the last 12 hours belong to the first half of the next Julian day. See the examples below.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; juldate = 2458444.0D
IDL&gt; rc = jul2iso(juldate, isodate, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;isodate = &#39; + isodate
isodate = 2018-11-21T12:00:00Z

IDL&gt; juldate = 2458443.9D
IDL&gt; rc = jul2iso(juldate, isodate, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;isodate = &#39; + isodate
isodate = 2018-11-21T09:36:00Z</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p><a href="https://www.w3.org/TR/NOTE-datetime" class="uri">https://www.w3.org/TR/NOTE-datetime</a>, accessed on 21 November 2018.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;11&#8211;20: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2018&#8211;11&#8211;30: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;02&#8211;24: Version 2.01 &#8212; Documentation update.</p></li>
</ul></li>
</ul>
<h2>last_char</h2>
<ul>
<li><p><strong>Purpose:</strong> This function returns the last character of the input positional parameter <code>arg</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function relies on <code>IDL</code> built-in string functions to extract the desired character.</p></li>
<li><p><strong>Syntax:</strong> <code>res = last_char(arg, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg {STRING} [I]:</code> An arbitrary string expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>STRING</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns the last character of the input positional parameter, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns a null string, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>arg</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 120: Positional parameter <code>arg</code> does not contain at least one character.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This may be useful, for instance, to check whether a directory name is terminated by the proper path segment separator character for the current operating system.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; path = &#39;/Volumes/MISR_Data&#39;
IDL&gt; PRINT, last_char(path)
a

IDL&gt; pi = 3.14
IDL&gt; res = last_char(pi, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;res = &gt;&#39; + res + &#39;&lt; and excpt_cond = &#39; + excpt_cond
res = &gt;&lt; and excpt_cond = Error 110 in LAST_CHAR:
   Input positional parameter must be of type STRING.

IDL&gt; PRINT, last_char(xyz)
% STRLEN: Variable is undefined: ARG.
% Execution halted at: LAST_CHAR...
%                      $MAIN$</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>make_bytemap</h2>
<ul>
<li><p><strong>Purpose:</strong> This function generates and saves, in the folder <code>save_spec</code>, a PNG-formatted graphic representation of the input positional parameter <code>byte_array</code>, where the <code>BYTE</code> values contained in the array <code>good_vals</code> are coded in the colors contained in the array <code>good_vals_cols</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function creates a graphical representation of the 2-D array <code>byte_array</code> where the values contained in <code>good_vals</code> are plotted in the corresponding colors given in <code>good_vals_cols</code>. Values in the data array that are not listed in <code>good_vals</code> are assigned the default color <code>0</code>, which is black. The list of recognized colors is defined by the World Wide Web Consortium (W3C) and are listed in the IDL documentation under the entry <code>!COLOR</code>.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = make_bytemap(byte_array, good_vals, good_vals_cols, $</code><br />
<code>save_spec, DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>byte_array {BYTE array} [I]:</code> A 2-D array of values of type <code>BYTE</code>.</p></li>
<li><p><code>good_vals {BYTE array} [I]:</code> A 1-D array of values of type <code>BYTE</code>.</p></li>
<li><p><code>good_vals_cols {STRING array} [I]:</code> A 1-D array of standard color names, as defined by W3C or IDL.</p></li>
<li><p><code>save_spec {STRING} [I]:</code> The file specification to be used to save the graphic file.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided in the call. The output graphic file is saved in the location specified by the input positional parameter <code>save_spec</code>.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output graphic file is not generated and is not saved.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input positional parameter <code>byte_array</code> is not of type <code>BYTE</code>.</p></li>
<li><p>Error 120: Input positional parameter <code>byte_array</code> is not a 2D array.</p></li>
<li><p>Error 130: Input positional parameter <code>good_vals</code> is not of type <code>BYTE</code> or <code>INT</code>.</p></li>
<li><p>Error 140: Input positional parameter <code>good_vals</code> contains none or more than 256 values.</p></li>
<li><p>Error 150: Input positional parameter <code>good_vals_cols</code> must be of type <code>STRING</code>.</p></li>
<li><p>Error 160: Input positional parameter <code>good_vals_cols</code> contains none or more than 256 values.</p></li>
<li><p>Error 170: Input positional parameters <code>good_vals</code> and <code>good_vals_cols</code> must have the same dimensions.</p></li>
<li><p>Error 180: At least one of the specified color names is unrecognized.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> Values contained in the input data array <code>byte_array</code> that are not listed in the input array <code>good_vals</code> have no explicitly assigned color code in the map, which defaults to a color code <code>0</code>, and hence to the first color listed in <code>good_vals_cols</code>.</p></li>
<li><p><strong>Note 2:</strong> Different values of the input array <code>good_vals</code> can be assigned the same color in <code>good_vals_cols</code>, as long as these two arrays have the same dimension to ensure the correspondence between their matching elements.</p></li>
<li><p><strong>Note 3:</strong> A given value of the input array <code>good_vals</code> can be assigned multiple colors in <code>good_vals_cols</code>, as long as these two arrays have the same dimension to ensure the correspondence between their matching elements. In that case, assignments associated with a higher index in those files supersede those made previously.</p></li>
<li><p><strong>Note 4:</strong> The input array <code>good_vals</code> may contain values that are not present in the input data array <code>byte_array</code>, as long as the input array <code>good_vals_cols</code> also contains a nominal color assignment, which will be ignored.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; byte_array = BYTARR(200, 50)
IDL&gt; FOR i = 0, 146 DO byte_array[i, *] = BYTE(i)
IDL&gt; good_vals = BINDGEN(147)
IDL&gt; good_vals_cols = TAG_NAMES(!COLOR)
IDL&gt; rc = make_bytemap(byte_array, good_vals, $
   good_vals_cols, &#39;/Users/michel/Desktop/test.png&#39;, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;rc = &#39; + strstr(rc) + &#39; and excpt_cond = &gt;&#39; + $
   excpt_cond + &#39;&lt;&#39;
rc = 0 and excpt_cond = &gt;&lt;</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p>See the color conventions recommended by the World Wide Web Consortium (W3C) [<a href="https://www.w3.org/TR/2018/REC-css-color-3-20180619/" class="uri">https://www.w3.org/TR/2018/REC-css-color-3-20180619/</a>], or the IDL documentation under the entry <code>!COLOR</code>.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;08&#8211;04: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2018&#8211;08&#8211;10: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;09&#8211;25: Version 1.1 &#8212; Move the code line to document the nature and properties of the input positional parameter <code>byte_array</code> before the initial testing block to ensure the function works when the <code>DEBUG</code> option is not used.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>oom</h2>
<ul>
<li><p><strong>Purpose:</strong> This routine returns an integer value representing the order of magnitude of the input positional parameter <code>arg</code> in the optional logarithmic base <code>base</code> (10 by default).</p></li>
<li><p><strong>Algorithm:</strong> The input positional parameters <code>arg</code> and the input keyword parameter <code>base</code> (if provided) must both be strictly positive numbers, in which case this function returns <code>FLOOR(alogb(arg, base))</code>. If either is not strictly positive, the function returns <code>NaN</code> and raises an exception condition.</p></li>
<li><p><strong>Syntax:</strong> <code>res = oom(arg, BASE = base, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg</code> is an arbitrary but strictly positive numeric expression.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>BASE = base {Numeric} [I] (Default value: 10.0):</code> An arbitrary but strictly positive numeric expression.</p></li>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns the order of magnitude of input positional parameter <code>arg</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns <code>NaN</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>arg</code> is not of type numeric.</p></li>
<li><p>Error 120: Positional parameter <code>arg</code> is not strictly positive.</p></li>
<li><p>Error 130: Keyword parameter <code>base</code> is not of type numeric.</p></li>
<li><p>Error 140: Keyword parameter <code>base</code> is not strictly positive.</p></li>
<li><p>Error 200: An exception condition occurred in <code>alogb.pro</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> Positional parameter <code>arg</code> and keyword parameter <code>base</code> must both be strictly positive numbers. If the order of magnitude of a negative number is required, provide the absolute value of that number as the input positional parameter to <code>oom</code>.</p></li>
<li><p><strong>Note 2:</strong> Input positional parameters <code>arg</code> and <code>base</code> can be of any numeric type, including <code>COMPLEX</code> or <code>DOUBLE</code>; the result will be of the same type as <code>arg</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = 99.9
IDL&gt; PRINT, oom(a)
           1

IDL&gt; b = 100.0
IDL&gt; PRINT, oom(b)
           2

IDL&gt; c = 123
IDL&gt; PRINT, oom(c, BASE = 5)
           2

IDL&gt; d = 123.45
IDL&gt; PRINT, oom(e, BASE = 2.8)
           4

IDL&gt; f = -12
IDL&gt; PRINT, oom(f, /DEBUG, EXCPT_COND = excpt_cond)
          NaN
IDL&gt; PRINT, excpt_cond
Error 120 in routine OOM: Input positional parameter
   arg is not strictly positive.</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.8 &#8212; Initial release.</p></li>
<li><p>2017&#8211;07&#8211;11: Version 0.9 &#8212; Moved former input positional parameter <code>base</code> into an optional keyword parameter.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>percentile</h2>
<ul>
<li><p><strong>Purpose:</strong> This function estimates the sample value <code>thresh</code> of the specified percentile <code>per</code> in the input <code>array</code> and returns some basic statistical information on that <code>array</code>, which may contain missing values and may but does not need to be sorted in ascending order.</p></li>
<li><p><strong>Algorithm:</strong> This function determines the sample value corresponding to the desired percentile <code>per</code> by either selecting a particular item of <code>array</code>, if it corresponds exactly, or interpolating between two <code>array</code> sample values otherwise. If missing values may be present in <code>array</code> (i.e., input keyword parameter <code>AMISS</code> is set), the output keyword parameters <code>amin</code> and <code>amax</code> report the minimum and maximum valid values within the allowed range <code>[FLOAT(ign_bel_str), FLOAT(ign_abo_str)]</code>; otherwise <code>amin</code> and <code>amax</code> report the minimum and maximum values within the entire <code>array</code>.</p></li>
<li><p><strong>Syntax:</strong> <code>res = percentile(per, array, amin, amax, thresh, $</code><br />
<code>AMISS = amiss, IGN_BEL_STR = ign_bel_str, $</code><br />
<code>IGN_ABO_STR = ign_abo_str, ASORT = asort, $</code><br />
<code>COUNT = count, DOUBLE = double, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond</code>)</p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>per {FLOAT} [I]:</code> The desired percentile, a decimal number between 0.0 and 1.0.</p></li>
<li><p><code>array {FLOAT array} [I]:</code> The statistical sample from which the percentile needs to be estimated.</p></li>
<li><p><code>amin {FLOAT} [O]:</code> The minimum value of array, within the allowed range<br />
<code>[FLOAT(ign_bel_str), FLOAT(ign_abo_str)]</code>, if these input positional parameters are provided, or within the whole array otherwise. <code>DOUBLE</code> precision equivalents are used if required.</p></li>
<li><p><code>amax {FLOAT} [O]:</code> The maximum value of array, within the allowed range<br />
<code>[FLOAT(ign_bel_str), FLOAT(ign_abo_str)]</code>, if these input positional parameters are provided, or within the whole array otherwise. <code>DOUBLE</code> precision equivalents are used if required.</p></li>
<li><p><code>thresh {FLOAT} [O]:</code> The threshold value in the given array, within the allowed range <code>[FLOAT(ign_bel_str),FLOAT(ign_abo_str)]</code>, if specified, such that <code>per</code> percents of the sorted array are below or equal to thresh.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>AMISS = amiss {INT} [I]:</code> Flag indicating whether the array contains (<code>1</code>) or does not contain (<code>0</code>) missing values. If missing values are present in <code>array</code>, they are assumed to be strictly smaller than the numerical equivalent of <code>ign_bel_str</code> or strictly larger than the numerical equivalent of <code>ign_abo_str</code>.</p></li>
<li><p><code>IGN_BEL_STR = ign_bel_str {STRING} [I]:</code> Threshold value provided as a string: If the <code>AMISS</code> keyword has been set, this keyword is mandatory and all array values strictly lower than the numerical equivalent to that string are ignored for the purpose of computing statistics and <code>thresh</code>. If the <code>AMISS</code> keyword has not been set, this keyword is ignored. See the notes below for additional information.</p></li>
<li><p><code>IGN_ABO_STR = ign_abo_str {STRING} [I]:</code> Threshold value provided as a string: If the <code>AMISS</code> keyword has been set, this keyword is mandatory and all array values strictly higher than the numerical equivalent to that string are ignored for the purpose of computing statistics and <code>thresh</code>. If the <code>AMISS</code> keyword has not been set, this keyword is ignored. See the notes below for additional information.</p></li>
<li><p><code>ASORT = asort {INT} [I]:</code> Flag indicating whether <code>array</code> is already sorted in ascending order (<code>1</code>) or not (<code>0</code>).</p></li>
<li><p><code>COUNT = count {LONG} [O]:</code> If the keyword parameter <code>AMISS</code> is not set, <code>count</code> is the number of elements of <code>array</code>. If the keyword parameter <code>AMISS</code> is set, <code>count</code> reports on the number of non-missing elements in <code>array</code> that were considered in the estimation of the percentile <code>thresh</code> (i.e., the number of <code>array</code> elements within the range<br />
<code>[FLOAT(ign_bel_str), FLOAT(ign_abo_str)]</code>.</p></li>
<li><p><code>DOUBLE = double {INT} [I]:</code> Flag requesting explicitly (<code>1</code>) that computations be carried out in double precision or not (<code>0</code>).</p></li>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> was set and if the optional output keyword parameter <code>EXCPT_COND</code> was provided in the call. The output positional parameters <code>amin</code>, <code>amax</code> and <code>thresh</code> provide the minimum and maximum values of the input positional parameter <code>array</code> and the desired percentile, respectively.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero value, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameters <code>thresh</code>, <code>amin</code> and <code>amax</code> are set to <code>!VALUES.F_INFINITY</code>.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Warning 10: Keyword parameter <code>IGN_BEL_STR</code> was provided as numerical value and has been converted to a string. Processing continues.</p></li>
<li><p>Warning 20: Keyword parameter <code>IGN_ABO_STR</code> was provided as numerical value and has been converted to a string. Processing continues.</p></li>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: The requested percentile is not within [0.0, 1.0].</p></li>
<li><p>Error 120: Input positional parameter <code>array</code> is not an array or not numeric.</p></li>
<li><p>Error 130: Input positional parameter <code>array</code> contains less than 4 elements.</p></li>
<li><p>Error 140: Keyword AMISS was set but keyword <code>IGN_BEL_STR</code> was not.</p></li>
<li><p>Error 150: Keyword AMISS was set but keyword <code>IGN_ABO_STR</code> was not.</p></li>
<li><p>Error 160: Input positional parameter <code>array</code> contains less than 2 non-missing values.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The input positional parameter <code>array</code> can be multi-dimensional, but the resulting <code>thresh</code> applies to all elements of <code>array</code>.</p></li>
<li><p><strong>Note 2:</strong> The keyword parameters <code>ign_bel_str</code> and <code>ign_abo_str</code> must be provided as strings because <code>IDL</code> interprets a null value as meaning that this keyword is NOT set (rather than being set to a null value).</p></li>
<li><p><strong>Note 3:</strong> If missing values may be present in <code>array</code> (i.e., input keyword parameter <code>AMISS</code> is set), the output keyword parameters <code>amin</code> and <code>amax</code> report the minimum and maximum valid values within the allowed range <code>[FLOAT(ign_bel_str), FLOAT(ign_abo_str)]</code>; otherwise <code>amin</code> and <code>amax</code> report the minimum and maximum values within the entire <code>array</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = [1, 7, 3, -99, 4, 5, -99, 9, 6, 2, 8]
IDL&gt; PRINT, N_ELEMENTS(a), MIN(a), MAX(a)
          11     -99       9
IDL&gt; res = percentile(0.5, a, amin, amax, thresh, /AMISS, $
   IGN_BEL_STR = &#39;0&#39;, IGN_ABO_STR = &#39;100&#39;, COUNT = count, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res, &#39;   &gt;&#39; + excpt_cond + &#39;&lt;&#39;
       0   &gt;&lt;
IDL&gt; PRINT, thresh, count, amin, amax
       5           9       1       9

IDL&gt; res = percentile(0.5, a, amin, amax, thresh, /AMISS, $
IDL&gt;    IGN_BEL_STR = &#39;0&#39;, IGN_ABO_STR = 100, COUNT = count, $
&gt;    /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, thresh, count, amin, amax
       5           9       1       9
IDL&gt; PRINT, excpt_cond
Warning 20 in PERCENTILE: Keyword IGN_ABO_STR, provided as
numerical value was converted to a STRING. Processing continues.</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p>Web page<br />
<code>http://www.itl.nist.gov/div898/handbook/prc/section2/prc252.htm</code>,<br />
visited on 30 Oct 2017.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2008&#8211;01&#8211;01: Version 0.5 &#8212; Initial release under the name <code>prctl</code>.</p></li>
<li><p>2008&#8211;10&#8211;14: Version 0.6 &#8212; Corrections to the documentation.</p></li>
<li><p>2015&#8211;04&#8211;05: Version 0.7 &#8212; Add reporting the min and max values within the allowable range.</p></li>
<li><p>2017&#8211;01&#8211;05: Version 0.8 &#8212; Update in-line documentation and add the optional <code>COUNT</code> keyword parameter.</p></li>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Changed function name to percentile, converted some of the input positional parameters into keyword parameters, updated the in-line documentation, implemented the keywords <code>ignore_below</code> and <code>ignore_above</code> as strings to avoid the incorrect interpretation of a null value.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>round_dec</h2>
<ul>
<li><p><strong>Purpose:</strong> This function rounds the input positional parameter <code>arg</code> to a new representation with only <code>n_dec</code> significant decimals.</p></li>
<li><p><strong>Algorithm:</strong> This function implements the following rules:</p>
<ul>
<li><p>If <code>arg</code> is of type <code>BYTE</code> (code 1), <code>INT</code> (code 2), <code>LONG</code> (code 3), <code>UINT</code> (code 12), <code>ULONG</code> (code 13), <code>LONG64</code> (code 14), or <code>ULONG64</code> (code 15), the function returns the input positional parameter <code>arg</code> unmodified.</p></li>
<li><p>If <code>arg</code> is of type <code>FLOAT</code> (code 4), the function returns the desired output provided the total number of significant digits of the input positional parameter does not exceed 6. The accuracy of the result for longer input positional parameters cannot be guaranteed.</p></li>
<li><p>If <code>arg</code> is of type <code>DOUBLE</code> (code 5), the function returns the desired output provided the total number of significant digits of the input positional parameter does not exceed 15. The accuracy of the result for longer input positional parameters cannot be guaranteed.</p></li>
<li><p>If <code>arg</code> is of a numeric type different than those mentioned above, the function returns <code>NaN</code>.</p></li>
<li><p>If <code>n_dec</code> is not of one of the numeric types, the function returns the value <code>NaN</code>; if <code>n_dec</code> is a non-integer numeric expression, its <code>INT</code> value, as returned by the <code>FIX</code> built-in function is used.</p></li>
</ul></li>
<li><p><strong>Syntax:</strong> <code>res = round_dec(arg, n_dec, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond</code>)</p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg {Number} [I]:</code> An arbitrary expression of type <code>FLOAT</code> or <code>DOUBLE</code>. Integer values are tolerated (the function returns the input unmodified). If <code>arg</code> is an array, each of its elements will be treated in the same way.</p></li>
<li><p><code>n_dec {INT} [I]:</code> The desired number of decimal digits in the result.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>Number</code> or <code>NaN</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected and the input positional parameter <code>arg</code> is of one of the <code>INTEGER</code> types, this function returns the value <code>arg</code> itself and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If no exception condition has been detected and the input positional parameter <code>arg</code> is either of type <code>FLOAT</code> or <code>DOUBLE</code>, this function returns a numeric approximation of the input positional parameter <code>arg</code>, rounded to <code>n_dec</code> significant decimals, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns <code>NaN</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input positional parameter <code>n_dec</code> must be numeric.</p></li>
<li><p>Error 120: Input positional parameter <code>arg</code> cannot be rounded because it is not numeric or <code>COMPLEX</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>type_of.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> Floating point numbers often cannot be represented internally with an exact number of decimals, hence, after rounding off, the returned number is the closest to the desired number but may still contain arbitrary digits in less significant places.</p></li>
<li><p><strong>Note 2:</strong> If the number of required decimals exceeds the inherent precision of the input number, this function returns a result equal to the input <code>arg</code>. See the examples below.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; arg = 12.345678
IDL&gt; n_dec = 2
IDL&gt; res = round_dec(arg, n_dec, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;arg = &#39;, arg, &#39;n_dec = &#39;, n_dec, &#39;res = &#39;, res, $
   FORMAT = &#39;(A6, 3X, F18.7, 3X, A8, I3, 3X, A6, F18.7)&#39;
arg = 12.3456783   n_dec = 2   res = 12.3500004

IDL&gt; arg = 12.987654
IDL&gt; n_dec = 1
IDL&gt; res = round_dec(arg, n_dec, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;arg = &#39;, arg, &#39;n_dec = &#39;, n_dec, &#39;res = &#39;, res, $
   FORMAT = &#39;(A6, 3X, F18.7, 3X, A8, I3, 3X, A6, F18.7)&#39;
arg = 12.9876537   n_dec = 1   res = 13.0000000

IDL&gt; arg = [1.23456, 2.34567]
IDL&gt; n_dec = 1
IDL&gt; res = round_dec(arg, n_dec, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, arg
      1.23456      2.34567
IDL&gt; PRINT, res
      1.20000      2.30000</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;04&#8211;17: Version 2.01 &#8212; Update the code to always round the decimal part of the input argument to 64-bit integers.</p></li>
</ul></li>
</ul>
<h2>set_cap</h2>
<ul>
<li><p><strong>Purpose:</strong> This function capitalizes the first word, and optionally each word or all characters, of the input positional parameter <code>arg</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function scans the input positional parameter <code>arg</code> to identify the first valid letter and capitalizes it. This operation can also be optionally performed on each word (continuous sequence of letters) or on all characters.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = set_cap, arg, $</code><br />
<code>ALLCHARS = allchars, ALLWORDS = allwords, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg {STRING} [I]:</code> The string that needs to be capitalized.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>ALLCHARS = allchars {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) capitalizing all characters of the input positional parameter <code>arg</code>.</p></li>
<li><p><code>ALLWORDS = allwords {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) capitalizing all words of the input positional parameter <code>arg</code>.</p></li>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>STRING</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns a version of the input positional parameter <code>arg</code>, capitalized as follows:</p>
<ul>
<li><p>If neither of the optional keyword parameters <code>ALLCHARS</code> and <code>ALLWORDS</code> are set (default), the first letter of the first word of <code>arg</code> is set in upper case.</p></li>
<li><p>If the optional keyword parameter <code>ALLCHARS</code> is set, all letters of <code>arg</code> are set in upper case.</p></li>
<li><p>If the optional keyword parameter <code>ALLWORDS</code> is set, each word of <code>arg</code> is set in upper case.</p></li>
<li><p>If both optional keyword parameters <code>ALLCHARS</code> and <code>ALLWORDS</code> are set, the former takes precedence and all letters of <code>arg</code> are set in upper case.</p></li>
<li><p>The input positional parameter <code>arg</code> is left unmodified.</p></li>
</ul>
<p>In all of these cases, the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided in the call.</p></li>
<li><p>If an exception condition has been detected, this function returns a null string, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input positional parameter <code>arg</code> is not of type <code>STRING</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_array.pro</code></p></li>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The input positional parameter <code>arg</code> may be a <code>STRING</code> array, in which case all elements of that array are processed as indicated above.</p></li>
<li><p><strong>Note 2:</strong> Characters other than letters are ignored and copied over verbatim to the returned value.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; PRINT, set_cap(&#39;south africa&#39;)
South africa

IDL&gt; PRINT, set_cap(&#39;hello&#39;, /ALLCHARS)
HELLO

IDL&gt; PRINT, set_cap(&#39; 12  hello&#39;, /ALLCHARS)
 12  HELLO

IDL&gt; PRINT, set_cap([&#39;south africa&#39;, &#39;united states&#39;], /ALLWORDS)
South Africa United States</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;12&#8211;02: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2018&#8211;12&#8211;12: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>set_value_range</h2>
<ul>
<li><p><strong>Purpose:</strong> This function returns an &#8216;optimal&#8217; value range to be used in plotting routines, based on the actual minimum and maximum values of the variable to be displayed. It can substitute the default range used by <code>IDL</code> in the <code>PLOT</code> function, if the latter is not satisfactory.</p></li>
<li><p><strong>Algorithm:</strong> This function selects the minimum and maximum values of a range that contains the values provided as input, decreased and increased by about 1/10th of the range between those values, and appropriately rounded.</p></li>
<li><p><strong>Syntax:</strong> <code>res = set_value_range(min_val, max_val, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>min_val {FLOAT} [I]:</code> The actual minimum valid value in a dataset, i.e., not considering special codes for missing values.</p></li>
<li><p><code>max_val {FLOAT} [I]:</code> The actual maximum valid value in a dataset, i.e., not considering special codes for missing values.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>FLOAT array</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns the optimal range to plot values within <code>[min_val, max_val]</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns the dummy range <code>res = [-99.9, -99.9]</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>min_val</code> or <code>max_val</code> is not of numeric type.</p></li>
<li><p>Error 120: The actual range <code>max_val - min_val</code> is null.</p></li>
<li><p>Error 130: An exception condition occurred in routine <code>oom.pro</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>oom.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong> None.</p></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; res = set_value_range(0.12, 0.62, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
      0.00000     0.700000
IDL&gt; PRINT, &#39;excpt_cond = &gt;&#39; + excpt_cond + &#39;&lt;&#39;
excpt_cond = &gt;&lt;

IDL&gt; res = set_value_range(-2.5, 12.7, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
     -10.0000      20.0000
IDL&gt; PRINT, &#39;excpt_cond = &gt;&#39; + excpt_cond + &#39;&lt;&#39;
excpt_cond = &gt;&lt;

IDL&gt; res = set_value_range(15.0, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
     -99.9000     -99.9000
IDL&gt; PRINT, &#39;excpt_cond = &#39; + excpt_cond
excpt_cond = Error 100 in set_value_range: Routine must be
   called with 2 positional parameters: min_val, max_val.</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>set_year_range</h2>
<ul>
<li><p><strong>Purpose:</strong> This function returns a time interval, defined by two Julian dates, containing complete common years, that includes the time interval specified by <code>jul_ini_date</code> and <code>jul_fin_date</code>.</p></li>
<li><p><strong>Algorithm:</strong> This routines returns an array of two Julian dates ranging from the 31st of December of the year before the specified initial date to the 1st of January of the year following the specified final date.</p></li>
<li><p><strong>Syntax:</strong> <code>res = set_year_range(jul_ini_date, jul_fin_date, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>jul_ini_date {DOUBLE} [I]:</code> The initial Julian date.</p></li>
<li><p><code>jul_fin_date {DOUBLE} [I]:</code> The final Julian date.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>DOUBLE array</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns the date interval that includes the time interval specified by <code>jul_ini_date</code> and <code>jul_fin_date</code> and comprises full common years. The output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns the dummy range <code>res = [-99.9D, -99.9D]</code>, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input positional parameters <code>jul_ini_date</code> and <code>jul_fin_date</code> must both be of numeric type.</p></li>
<li><p>Error 120: Input positional parameters <code>jul_ini_date</code> and <code>jul_fin_date</code> must both be scalars.</p></li>
<li><p>Error 130: Input positional parameters <code>jul_ini_date</code> and <code>jul_fin_date</code> must both be posterior to 4 October 1582.</p></li>
<li><p>Error 140: Julian date <code>jul_ini_date</code> must precede Julian date <code>jul_fin_date</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function is useful to set the time axis on time series plots so that the graphic display includes full common years.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; jul1 = JULDAY(2, 24, 2000)
IDL&gt; jul2 = JULDAY(6, 13, 2015)
IDL&gt; PRINT, jul1, jul2
     2451599     2457187
IDL&gt; res = set_year_range(jul1, jul2, /DEBUG, $
   EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
     2451544     2457389
IDL&gt; PRINT, &#39;excpt_cond = &gt;&#39; + excpt_cond + &#39;&lt;&#39;
excpt_cond = &gt;&lt;
IDL&gt; CALDAT, 2451544, mo1, dy1, yr1
IDL&gt; CALDAT, 2457389, mo2, dy2, yr2
IDL&gt; PRINT, mo1, dy1, yr1
          12          31        1999
IDL&gt; PRINT, mo2, dy2, yr2
           1           1        2016

IDL&gt; res = set_year_range(jul2, jul1, /DEBUG, $
   EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
     -99.9000     -99.9000
IDL&gt; PRINT, &#39;excpt_cond = &#39; + excpt_cond
excpt_cond = Error 140 in SET_YEAR_RANGE:
   Julian date &#39;jul_ini_date&#39; = 2457187.0 must precede
   Julian date &#39;jul_fin_date&#39; = 2451599.0.</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>sha256</h2>
<ul>
<li><p><strong>Purpose:</strong> This function returns the SHA-2 (256 bits) hash signature of the input file <code>file_spec</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function spawns a Bash shell script using the Linux command <code>shasum -a 256</code> and returns the signature to the calling routine.</p></li>
<li><p><strong>Syntax:</strong> <code>res = sha256(file_spec, DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>file_spec {STRING} [I]:</code> The input file specification, with an optional path but a mandatory name, of the file to characterize.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>STRING</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns the SHA-2 (256 bits) hash signature of the input file, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns <code>&#8217;-1&#8217;</code>, and the keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: File <code>file_spec</code> is unreadable.</p></li>
<li><p>Error 120: File <code>file_spec</code> is not found.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_readable.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> This function may or may not work in a MS Windows environment, depending on whether a <code>shasum -a 256</code> command is available from the operating system.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; PRINT, sha256(&#39;./IDLWorkspace/Utilities/dummy.txt&#39;, $
   /DEBUG, EXCPT_COND = excpt_cond)
4ea226bae70b6dc623a62314486f7846ed5e458a0718082964925e735f2823ea</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p>Web page: <code>https://en.wikipedia.org/wiki/SHA-2</code>.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;04&#8211;24: Version 1.1 &#8212; Update debugging messages.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>strcat</h2>
<ul>
<li><p><strong>Purpose:</strong> This function returns a scalar <code>STRING</code> variable that combines all elements of the input positional parameter <code>str_array</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function concatenates the elements of the input positional parameter <code>str_array</code>, in their original order, into a single scalar <code>STRING</code> variable, using the input positional parameter <code>sep_char</code> character as separator between successive elements.</p></li>
<li><p><strong>Syntax:</strong> <code>res = strcat(str_array, separator, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>str_array {STRING} [I]:</code> An arbitrary string array.</p></li>
<li><p><code>separator {STRING} [I] (Default value: None):</code> Character string used to separate the array elements in the output string.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>STRING</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns a string scalar and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns a null string and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Input positional parameter <code>str_array</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 120: Input positional parameter <code>str_array</code> is not an array.</p></li>
<li><p>Error 130: Input positional parameter <code>sep_char</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 140: Input positional parameter <code>sep_char</code> is not a scalar.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_array.pro</code></p></li>
<li><p><code>is_scalar.pro</code></p></li>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The input positional parameter <code>str_array</code> can be multi-dimensional. In the case of a 2D array, the elements are concatenated line by line.</p></li>
<li><p><strong>Note 1:</strong> The input positional parameter <code>sep_char</code> can be a null string or contain multiple characters.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; a = [&#39;multi&#39;, &#39;spectral&#39;]
IDL&gt; res = strcat(a, &#39;&#39;)
IDL&gt; PRINT, &#39;&gt;&#39; + res + &#39;&lt;&#39;
&gt;multispectral&lt;

IDL&gt; str_array = [[&#39;This&#39;, &#39;is&#39;, &#39;a&#39;], [&#39;2D&#39;, &#39;string&#39;, &#39;array&#39;]]
IDL&gt; res = strcat(str_array, &#39; &#39;, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
This is a 2D string array

IDL&gt; str_array = [&#39;P168&#39;, &#39;O068050&#39;, &#39;B110&#39;]
IDL&gt; separator = &#39;_&#39;
IDL&gt; res = strcat(str_array, separator, $
   DEBUG = 1, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;res = &gt;&#39; + res + &#39;&lt;&#39;
res = &gt;P168_O068050_B110&lt;</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;18: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2018&#8211;12&#8211;04: Version 1.6 &#8212; Convert the input keyword parameter <code>sep_char</code> into the input positional parameter <code>separator</code> to allow concatenation with empty separators.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>strrepeat</h2>
<ul>
<li><p><strong>Purpose:</strong> This function generates and returns an output string containing <code>n_rep</code> times the input positional parameter <code>str</code>.</p></li>
<li><p><strong>Algorithm:</strong> This function replicates the input positional parameter <code>str</code> <code>n_rep</code> times and returns the result to the calling routine.</p></li>
<li><p><strong>Syntax:</strong> <code>res = strrepeat(str, n_rep, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>str {STRING} [I]:</code> A string expression.</p></li>
<li><p><code>n_rep {INT} [I]:</code> The total number of times the input string <code>str</code> needs to be replicated in the output string.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>STRING</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns a string scalar, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> was set and if the optional output keyword parameter <code>EXCPT_COND</code> was provided in the call.</p></li>
<li><p>If an exception condition has been detected, this function returns a null string and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>str</code> is not of type <code>STRING</code>.</p></li>
<li><p>Error 120: Positional parameter <code>n_rep</code> is not of type <code>INTEGER</code>.</p></li>
<li><p>Error 130: Positional parameter <code>n_rep</code> is negative.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_integer.pro</code></p></li>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> If the input positional parameter <code>n_rep</code> is <code>0</code>, this function returns a null string, irrespective of the content of the input positional parameter <code>str</code>.</p></li>
<li><p><strong>Note 2:</strong> If the input positional parameter <code>n_rep</code> is <code>1</code>, this function returns the value of <code>str</code>.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; res = strrepeat(&#39;--123--&#39;, 4, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, res
--123----123----123----123--

IDL&gt; title = &#39;This is a title&#39;
IDL&gt; PRINT, title, STRING(10B), strrepeat(&#39;-&#39;, STRLEN(title), $
   /DEBUG, EXCPT_COND = excpt_cond)
This is a title
---------------</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;08&#8211;01: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2018&#8211;12&#8211;04: Version 1.6 &#8212; Update the function documentation.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>strstr</h2>
<ul>
<li><p><strong>Purpose:</strong> This function converts the value of the alphanumeric positional parameter <code>arg</code> into a string without any white space in the front or at the back.</p></li>
<li><p><strong>Algorithm:</strong> This routine converts the input positional parameter <code>arg</code> to a <code>STRING</code> and strips any white space in the front or back.</p></li>
<li><p><strong>Syntax:</strong> <code>res = strstr(arg, DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>arg {alphanumeric} [I]:</code> The alphanumeric input variable to process.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>STRING</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns the string representation of the input positional parameter <code>arg</code> to the calling routine, and the keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
<li><p>If an exception condition has been detected, this function returns a null string and the keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Positional parameter <code>arg</code> is not of type alphanumeric.</p></li>
<li><p>Error 200: Unexpected condition, check the type of input positional parameter <code>arg</code>.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_alphanum.pro</code></p></li>
<li><p><code>is_numeric.pro</code></p></li>
<li><p><code>is_string.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The input positional parameter <code>arg</code> can be an array, in which case each array element is converted into a string without any blank space in the front or at the back.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; pi = 3.14159
IDL&gt; PRINT, pi
      3.14159
IDL&gt; res = strstr(pi)
IDL&gt; PRINT, res
3.14159

IDL&gt; a = &#39;   Hello   &#39;
IDL&gt; PRINT, &#39;&gt;&#39; + a + &#39;&lt;&#39;
&gt;   Hello   &lt;
IDL&gt; res = strstr(a)
IDL&gt; PRINT, &#39;&gt;&#39; + res + &#39;&lt;&#39;
&gt;Hello&lt;

IDL&gt; a = CREATE_STRUCT(&#39;A&#39;, 1, &#39;B&#39;, &#39;xxx&#39;)
IDL&gt; res = strstr(a, /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;&gt;&#39; + res + &#39;&lt;&#39;
&gt;&lt;
IDL&gt; PRINT, excpt_cond
Error 110 in routine STRSTR: Input positional
   parameter arg is not an alphanumeric expression.

IDL&gt; b = [&#39;   Hello   &#39;, &#39;   World   &#39;]
IDL&gt; res = strstr(b)
IDL&gt; PRINT, &#39;&gt;&#39; + res[0] + &#39;&lt;&#39; + &#39; &#39; + &#39;&gt;&#39; + res[1] + &#39;&lt;&#39;
&gt;Hello&lt; &gt;World&lt;</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>today</h2>
<ul>
<li><p><strong>Purpose:</strong> This function returns today&#8217;s date and time as a string in one of the following formats: default (keyword <code>FMT</code> not set), <code>iso</code>, <code>jul</code>, <code>julian</code>, <code>nice</code>, <code>usa</code> or <code>ymd</code>.</p></li>
<li><p><strong>Algorithm:</strong> This routine implements some of the recommendations by World Wide Web Consortium (W3C) regarding simplified formats to represent dates and times, as provided originally by the ISO 8601 standard. It relies on the <code>IDL</code> function <code>SYSTIME</code> to generate the information (in <code>IDL</code>&#8217;s format) and reformats the result as described below.</p></li>
<li><p><strong>Syntax:</strong> <code>res = today(FMT = fmt)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong> None.</p></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>FMT = fmt {STRING} [I]:</code> Set this optional keyword to <code>iso</code>, <code>nice</code>, <code>usa</code> or <code>ymd</code> to generate the return value in a format different from the default. If the value of this keyword is not set or unrecognized, the result will be formatted according to the default format.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>STRING</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>This function returns today&#8217;s date to the calling routine in one of the following formats:</p>
<ul>
<li><p>If the keyword <code>FMT</code> is NOT set (default), or is unrecognized, the current date and time are provided as a string formatted like <code>YYYY-MM-DD_hh:mm:ss</code>.</p></li>
<li><p>If the keyword <code>FMT</code> is set to <code>iso</code>, the current date and time are provided as a string formatted like <code>YYYY-MM-DDThh:mm:ssZ</code>.</p></li>
<li><p>If the keyword <code>FMT</code> is set to <code>jul</code>, the current date is provided as the current Julian day number, i.e., a <code>STRING</code> representation of a <code>LONG</code> integer.</p></li>
<li><p>If the keyword <code>FMT</code> is set to <code>julian</code>, the current date and time are provided as the current Julian day number and time, i.e., a <code>STRING</code> representation of a <code>DOUBLE</code> floating point number.</p></li>
<li><p>If the keyword <code>FMT</code> is set to <code>nice</code>, the current date and time are provided as a string formatted like <code>YYYY-MM-DD at hh:mm:ss</code>.</p></li>
<li><p>If the keyword <code>FMT</code> is set to <code>usa</code>, the current date is provided as a string formatted like <code>Mo DD, YYYY</code>, where <code>Mon</code> is a 3-character string abreviation of the month name.</p></li>
<li><p>If the keyword <code>FMT</code> is set to <code>ymd</code>, the current date is provided as a string formatted like <code>YYYY-MM-DD</code>.</p></li>
</ul></li>
<li><p>This routine does not provide diagnostic information on exception conditions.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong> None.</p></li>
<li><p><strong>Dependencies:</strong> None.</p></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The format option <code>FMT</code> can be specified in either upper or lower (or even mixed) case.</p></li>
<li><p><strong>Note 2:</strong> This routine does not (currently) attempt to report on the time zone.</p></li>
<li><p><strong>Note 3:</strong> The output formats <code>nice</code> and <code>usa</code> may be less desirable for use in filenames because of the presence of blank characters.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; res = today()
IDL&gt; PRINT, res
2017-03-09_20-56-45

IDL&gt; res = today(FMT = &#39;nice&#39;)
IDL&gt; PRINT, res
2017-03-09 at 20:57:14

IDL&gt; res = today(FMT = &#39;ymd&#39;)
IDL&gt; PRINT, res
2017-03-09</code></pre></li>
<li><p><strong>References:</strong></p>
<ul>
<li><p>Web page: <code>https://www.w3.org/TR/NOTE-datetime</code>.</p></li>
</ul></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2017&#8211;07&#8211;05: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2017&#8211;11&#8211;20: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;01&#8211;15: Version 1.1 &#8212; Implement optional debugging.</p></li>
<li><p>2019&#8211;01&#8211;04: Version 1.2 &#8212; Add the optional output formats <code>jul</code> and <code>julday</code>.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
</ul></li>
</ul>
<h2>uniq2</h2>
<ul>
<li><p><strong>Purpose:</strong> This function sorts and sifts two one-dimensional arrays of identical type and dimensions, retaining only the couples of unique values while maintaining the correspondance between elements of the same rank in each input array.</p></li>
<li><p><strong>Algorithm:</strong> This function combines the two input positional parameter arrays into a single <code>STRING</code> array, sorts and sifts it to eliminate duplicates, and then splits it back into arrays of the original type but containing only unique pairs of corresponding values.</p></li>
<li><p><strong>Syntax:</strong> <code>rc = uniq2(in_array_1, in_array_2, out_array_1, out_array_2, $</code><br />
<code>DEBUG = debug, EXCPT_COND = excpt_cond)</code></p></li>
<li><p><strong>Positional parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>in_array_1 [I]:</code> An arbitrary array.</p></li>
<li><p><code>in_array_2 [I]:</code> An arbitrary array of the same type and size as <code>in_array_1</code>.</p></li>
<li><p><code>out_array_1 [O]:</code> An array of the same type and size as <code>in_array_1</code> containing the elements of <code>in_array_1</code> which are uniquely associated with elements of <code>in_array_2</code>.</p></li>
<li><p><code>out_array_2 [O]:</code> An array of the same type and size as <code>in_array_1</code> containing the elements of <code>in_array_2</code> which are uniquely associated with elements of <code>in_array_1</code>.</p></li>
</ul></li>
<li><p><strong>Keyword parameters [Input/Output]:</strong></p>
<ul>
<li><p><code>DEBUG = debug {INT} [I] (Default value: 0):</code> Flag to activate (<code>1</code>) or skip (<code>0</code>) debugging tests.</p></li>
<li><p><code>EXCPT_COND = excpt_cond {STRING} [O] (Default value: &#8221;):</code> Description of the exception condition if one has been encountered, or a null string otherwise.</p></li>
</ul></li>
<li><p><strong>Returned value type:</strong> <code>INT</code>.</p></li>
<li><p><strong>Outcome:</strong></p>
<ul>
<li><p>If no exception condition has been detected, this function returns <code>0</code>, and the output keyword parameter <code>excpt_cond</code> is set to a null string, if the optional input keyword parameter <code>DEBUG</code> was set and if the optional output keyword parameter <code>EXCPT_COND</code> was provided in the call. The output positional parameters <code>out_array_1</code> and <code>out_array_2</code> contain the unique combinations of values of the input positional parameters.</p></li>
<li><p>If an exception condition has been detected, this function returns a non-zero error code, and the output keyword parameter <code>excpt_cond</code> contains a message about the exception condition encountered, if the optional input keyword parameter <code>DEBUG</code> is set and if the optional output keyword parameter <code>EXCPT_COND</code> is provided. The output positional parameters may be undefined, inexistent, incomplete or useless.</p></li>
</ul></li>
<li><p><strong>Exception conditions:</strong></p>
<ul>
<li><p>Error 100: One or more positional parameter(s) are missing.</p></li>
<li><p>Error 110: Both input positional parameters <code>in_array_1</code> and <code>in_array_2</code> must be arrays.</p></li>
<li><p>Error 120: The input positional parameters <code>in_array_1</code> and <code>in_array_2</code> must be of the same size.</p></li>
<li><p>Error 130: The input positional parameters <code>in_array_1</code> and <code>in_array_2</code> must be of the same type.</p></li>
</ul></li>
<li><p><strong>Dependencies:</strong></p>
<ul>
<li><p><code>is_array.pro</code></p></li>
<li><p><code>strstr.pro</code></p></li>
<li><p><code>type_of.pro</code></p></li>
</ul></li>
<li><p><strong>Remarks:</strong></p>
<ul>
<li><p><strong>Note 1:</strong> The input positional parameters <code>in_array_1</code> and <code>in_array_2</code> can be of any alphanumeric type, but must be defined.</p></li>
</ul></li>
<li><p><strong>Examples:</strong></p>
<pre><code>IDL&gt; in_array_1 = [1.1, 1.1, 2.2, 2.2, 3.3, 3.3, $
   4.4, 4.4, 4.4, 2.2, 5.5]
IDL&gt; in_array_2 = [0.0, 0.0, 1.1, 2.2, 3.3, 3.3, $
   3.3, 4.4, 3.3, 2.2, 6.1]
IDL&gt; rc = uniq2(in_array_1, in_array_2, out_array_1, out_array_2, $
   /DEBUG, EXCPT_COND = excpt_cond)
IDL&gt; PRINT, &#39;rc = &#39; + strstr(rc) + &#39;, excpt_cond = &gt;&#39; + $
   excpt_cond + &#39;&lt;&#39;
rc = 0, excpt_cond = &gt;&lt;
IDL&gt; PRINT, out_array_1
1.10000  2.20000  2.20000  3.30000  4.40000  4.40000  5.50000
IDL&gt; PRINT, out_array_2
0.00000  1.10000  2.20000  3.30000  3.30000  4.40000  6.10000</code></pre></li>
<li><p><strong>References:</strong> None.</p></li>
<li><p><strong>Versioning:</strong></p>
<ul>
<li><p>2018&#8211;04&#8211;29: Version 0.9 &#8212; Initial release.</p></li>
<li><p>2018&#8211;05&#8211;14: Version 1.0 &#8212; Initial public release.</p></li>
<li><p>2018&#8211;06&#8211;01: Version 1.5 &#8212; Implement new coding standards.</p></li>
<li><p>2019&#8211;01&#8211;28: Version 2.00 &#8212; Systematic update of all routines to implement stricter coding standards and improve documentation.</p></li>
<li><p>2019&#8211;02&#8211;28: Version 2.01 &#8212; Documentation update.</p></li>
</ul></li>
</ul>
</body>
</html>
